2. Работа со списками загрузчика

Сейчас рассмотрим как получить список загруженных файлов(библиотек) в удаленное адресное пространство процесса.
Вообще, конечно, технически есть вполне себе штатный способ, через вызов EnumProcessModulesEx, но с ним есть нюанс - он не покажет данные по 64 битным модулям, будучи вызван из 32 битного процесса. 
В этом можно убедиться вот таким кодом:

  function EnumProcessModulesEx(hProcess: THandle; lphModule: PHandle;
    cb: DWORD; var lpcbNeeded: DWORD; dwFilterFlag: DWORD): BOOL; stdcall;
    external 'psapi.dll';

procedure TestEnumSelfModules;
const
  LIST_MODULES_ALL = 3;
var
  Buff: array of THandle;
  Needed: DWORD;
  I: Integer;
  FileName: array[0..MAX_PATH] of Char;
begin
  EnumProcessModulesEx(GetCurrentProcess, nil, 0, Needed, LIST_MODULES_ALL);
  SetLength(Buff, Needed shr 2);
  if EnumProcessModulesEx(GetCurrentProcess, @Buff[0], Needed, Needed, LIST_MODULES_ALL) then
  begin
    for I := 0 to Integer(Needed) - 1 do
      if Buff[I] <> 0 then
      begin
        FillChar(FileName, MAX_PATH, 0);
        GetModuleFileNameEx(GetCurrentProcess, Buff[I], @FileName[1], MAX_PATH);
        Writeln(I, ': ', IntToHex(Buff[I], 1), ' ', string(PChar(@FileName[1])));
      end;
  end;
end;

..\5.png

Слева то что он выведет, а справа реальная ситуация. Отображены только 32 битные модули загруженные из папки C:\Windows\SysWOW64\ причем из-за работающего редиректа этот факт от нас прячется и пути к библиотекам показываются как C:\Windows\System32\ хотя это на самом деле не так.
Такое ограничение вполне себе понятно, дело в том что он возвращает список инстансов, а инстанс это адрес загрузки библиотеки, т.е. указатель по сути, который для 32 бит может держать только 4 байта и не сможет вместить в себя полный 64 битный адрес.

Давайте сразу же уточню один момент. 
В 64 битной ОС НЕ СУШЕСТВУЕТ 32 битных процессов! Все процессы, без исключения, являются 64 битными, и когда стартует ваше 32 битное приложение, сначала инициализируется 64 битный процесс, в который загружаются библиотеки WOW64 подсистемы и только потом в него загружаются ваши 32 битные образы, которые работают с ОС не напрямую, а через WOW64 подсистему, конвертирующую все ваши 32 битные вызовы API в их 64 битные аналоги.
Именно поэтому:
1. В вашем 32 битном процессе постоянно присутствуют загруженные 64 битные библиотеки
2. Флаг IMAGE_FILE_LARGE_ADDRESS_AWARE выставленный в РЕ заголовке предоставляет вам доступ ко всем 4 гигабайтам памяти, а не к трем, как это будет на 32 битной OS при включенном PAE (Physical Address Extension) и флаге /3GB в boot.ini

Так как нам нужны все данные, то получать список загруженных модулей будем самостоятельно, через списки загрузчика.

Для это нужно произвести небольшую подготовку.
В модуль RawScanner.Types {линк} добавим три новых структуры TModuleData, UNICODE_STRING32 и UNICODE_STRING64, и создадим новый модуль RawScanner.Wow64 {линк}. Этот модуль будет содержать все необходимое для работы с 64 битными процессами, а именно обертки над следующими функциями:
1. IsWow64Process - для детекта работы WOW64 подсистемы
2. Wow64DisableWow64FsRedirection + Wow64RevertWow64FsRedirection - для отключения и включения редиректа библиотек из System32 в SysWOW64
3. NtWow64QueryInformationProcess64 - аналог функции NtQueryInformationProcess для работы с 64 битными процессами.
4. NtWow64ReadVirtualMemory64 - для чтения памяти удаленного процесса по 64 битным указателям, недоступным при вызове ReadProcessMemory

Так же в модуль RawScanner.Utils {линк} добавим функцию ReadRemoteMemory, в которой будет автоматически приниматься решение какой из вызовов использовать для чтения удаленной памяти.

Структура TModuleData и список TModuleList будут хранить информацию по загруженным модулям и использоваться на следующих этапах.

Итак, где хранятся все данные о загруженных библиотеках? Их формирует загрузчик для каждого процесса (причем в двух экземплярах если процесс 32 битный). Представляет из себя двунаправленный список, доступ к которому нужно получить из блока окружения процесса, который сам по себе также представляет структуру, одним из полей которой является поле PPEB_LDR_DATA Ldr.
https://learn.microsoft.com/ru-ru/windows/win32/api/winternl/ns-winternl-peb

Чтобы получить данные из списков загрузчика, нужно сначала научится правильно прочесть адрес начала этих списков.
У нас может быть четыре разных ситуации:
1. Мы 32 битное приложение, которое будет читать данные из 64 битного
2. Мы 64 битное приложение, которое будет читать данные из 32 битного
3. Мы приложение, которое будет читать данные из процесса такой-же битности (т.е. два разных случая под разную битность).

Для каждого из перечисленных вариантов применяется свой подход.
Давайте писать код (в тестовом консольном приложении).

Шаг первый, открываем процесс и проверяем его битность:

var
  hProcess: THandle;
  IsWow64Mode: LongBool;
begin
  hProcess := OpenProcess(
    PROCESS_QUERY_INFORMATION or PROCESS_VM_READ,
    False, GetCurrentProcessId);

  Wow64Support.IsWow64Process(hProcess, IsWow64Mode);
  
Флаг IsWow64Mode будет нам сигнализировать о том что удаленный процесс работает под WOW64 подсистемой и его мы будем обрабатывать дальше.
  
Следующим шагом нам потребуется декларация структуры блока окружения процесса (полная структура не нужна, достаточно будет только до поля загрузчика)

  TPEB = record
    InheritedAddressSpace: BOOLEAN;
    ReadImageFileExecOptions: BOOLEAN;
    BeingDebugged: BOOLEAN;
    BitField: BOOLEAN;
    Mutant: THandle;
    ImageBaseAddress: PVOID;
    LoaderData: PVOID; // именно это поле нас и интересует
  end;
  
После чего потребуются еще две декларации её-же только строго соответствующие битности списка загрузчика, из которого будет производится чтение.
Еще раз заострю внимание, у 32 битного процесса на 64 битной ОС таких списков будет два, соответственно блоков окружения процесса, через которые происходит выход на список так-же будет два, для 64 бит и 32-битный для WOW64! 

  TPEB32 = record
    InheritedAddressSpace: BOOLEAN;
    ReadImageFileExecOptions: BOOLEAN;
    BeingDebugged: BOOLEAN;
    BitField: BOOLEAN;
    Mutant: ULONG;
    ImageBaseAddress: ULONG;
    LoaderData: ULONG;
  end;
  
  TPEB64 = record
    InheritedAddressSpace: BOOLEAN;
    ReadImageFileExecOptions: BOOLEAN;
    BeingDebugged: BOOLEAN;
    BitField: BOOLEAN;
    Mutant: ULONG_PTR64;
    ImageBaseAddress: ULONG_PTR64;
    LoaderData: ULONG_PTR64;
  end;    
  
Загрузка данных будет достаточно тривиальная, посредством вызова NtQueryInformationProcess с флагом ProcessBasicInformation получаем информацию о процессе, в которой, помимо прочего будет поле PROCESS_BASIC_INFORMATION.PebBaseAddress, содержащий адрес блока окружения процесса. 
Вот из него мы и прочтем нужные нам данные.

function ReadNativePeb(hProcess: THandle; out APeb: TPEB64): Boolean;
const
  ProcessBasicInformation = 0;
var
  PBI: PROCESS_BASIC_INFORMATION;
  dwReturnLength: Cardinal;
  NativePeb: TPEB;
begin
  Result := NtQueryInformationProcess(hProcess,
    ProcessBasicInformation, @PBI, SizeOf(PBI), @dwReturnLength) = 0;
  if not Result then
    Exit;

  Result := ReadRemoteMemory(hProcess, ULONG_PTR64(PBI.PebBaseAddress),
    @NativePeb, SizeOf(TPEB));
  if Result then
  {$IFDEF WIN32}
    APeb := Convert32PebTo64(TPEB32(NativePeb));
  {$ELSE}
    APeb := TPEB64(NativePeb);
  {$ENDIF}
end;

Данная функция всегда возвращает 64 битный PEB, это сделано только для удобства работы с этой структурой. Если мы читаем 32 битный, то результат преобразуется в 64 битный аналог вызовом Convert32PebTo64.
Эта функция покрывает только два случая из четырех вышеперечисленных.
1. При чтении 32 битного PEB из 32 битного процесса (при этом мы сами находимся в 32 битной сборке)
2. При чтении 64 битного PEB из 64 битного процесса (при этом мы сами находимся в 64 битной сборке)

Рассмотрим остальные варианты.

function Read64PebFrom32Bit(hProcess: THandle; out APeb: TPEB64): Boolean;
const
  ProcessBasicInformation = 0;
var
  PBI64: PROCESS_BASIC_INFORMATION64;
  dwReturnLength: Cardinal;
begin
  Result := Wow64Support.QueryInformationProcess(hProcess,
    ProcessBasicInformation, @PBI64, SizeOf(PBI64), dwReturnLength);
  if not Result then
    Exit;

  Result := ReadRemoteMemory(hProcess, PBI64.PebBaseAddress,
    @APeb, SizeOf(TPEB64));
end;

Код практически идентичен предыдущему варианту за одним исключением, здесь мы так-же получаем информацию по процессу с флагом ProcessBasicInformation, но вызываем уже 64 битный вариант функции через WOW64 хэлпер, который возвращает информацию именно по 64 битному PEB, поэтому этап конвертации тут пропущен, ибо этот вызов всегда читает именно 64 битную структуру.
Данный вызов применяется только в случае когда мы находимся в 32 битной сборке и запущены на 64 битной ОС. Применяется для чтения 64 битного PEB в процессах любой битности.

И последний вариант:

function Read32PebFrom64Bit(hProcess: THandle; out APeb: TPEB64): Boolean;
const
  ProcessWow64Information = 26;
var
  PebWow64BaseAddress: ULONG_PTR;
  dwReturnLength: Cardinal;
  Peb32: TPEB32;
begin
  Result := NtQueryInformationProcess(hProcess,
    ProcessWow64Information, @PebWow64BaseAddress, SizeOf(ULONG_PTR),
    @dwReturnLength) = 0;
  if not Result then
    Exit;

  Result := ReadRemoteMemory(hProcess, PebWow64BaseAddress,
    @Peb32, SizeOf(TPEB32));
  if Result then
    APeb := Convert32PebTo64(Peb32);
end;

Этот вызов применяется строго из 64 битной сборки для чтения 32 битного PEB в 32 битном процессе (в 64 битном он отсутствует).
Из изменений, опять используется вызов NtQueryInformationProcess но уже с флагом ProcessWow64Information возвращающим информацию только по 32 битному PEB, поэтому в конце, при успешном чтении данных, идет этап конвертации в 64 битный аналог.

Для удобства подготовим вот такую функцию, которая сама будет вызывать нужный вариант кода в зависимости от текущей сборки приложения.

function ReadPeb(hProcess: THandle; Read32Peb: Boolean; out APeb: TPEB64): Boolean;
begin
  ZeroMemory(@APeb, SizeOf(TPEB64));
  if Read32Peb then
  {$IFDEF WIN32}
    Result := ReadNativePeb(hProcess, APeb)
  else
    Result := Read64PebFrom32Bit(hProcess, APeb);
  {$ELSE}
    Result := Read32PebFrom64Bit(hProcess, APeb)
  else
    Result := ReadNativePeb(hProcess, APeb);
  {$ENDIF}
end;

Ну и вызовем её дописав в тестовой консоли такой код:

var
  PEB32, PEB64: TPEB64;
  
  // загружаем блоки окружения процесса (если есть)
  ReadPeb(hProcess, True, PEB32);
  ReadPeb(hProcess, False, PEB64);

И вот только теперь, когда у нас на руках есть код чтения адреса загрузчика, можно приступать к работе с ним, для этого посмотрим на картинку.

..\6.png

Здесь я взял изображение из WinXP только по той причине, что в ней списки загрузчика расположены в памяти более компактно, чем в остальных версиях Windows, в которых они разбросаны по страницам сильно далеко друг от друга.

Прочитанная нами ранее структура PEB содержит указатель на структуру PEB_LDR_DATA, которая содержит ссылки на три публичных двунаправленных списка, состоящих из элементов LDR_DATA_TABLE_ENTRY.
Если посмотрим на декларацию в MSDN то в ней практически все поля спрятаны, кроме одного списка, содержащий список загруженных модулей отсортированный в порядке их размещения в памяти

https://learn.microsoft.com/ru-ru/windows/win32/api/winternl/ns-winternl-peb_ldr_data

Пропущен список InLoadOrderModuleList (сортировка в порядке загрузки) и InInitializationOrderModuleList (сортировка в порядке инициализации).
Вообще чисто технически, помимо этих трех списков, операционная система держит еще 32 таких-же, использующихся для ускорения работы того-же GetModuleHandle (поэтому когда пишут код, скрывающий себя из этих трех списков, типа руткит на минималках - всегда забывают еще и про дополнительные, скрытые).

Впрочем это лирика, сейчас хочу показать нюанс, на котором многие спотыкаются. 
А спотыкаются потому что в MSDN не правильное описание полей структуры (в смысле комментарий к ним).
Посмотрите на декларацию структур:

  LIST_ENTRY32 = record
    FLink, BLink: ULONG;
  end;

  PEB_LDR_DATA32 = record
    Length: ULONG;
    Initialized: BOOL;
    SsHandle: ULONG;
    InLoadOrderModuleList: LIST_ENTRY32;
    InMemoryOrderModuleList: LIST_ENTRY32;
    InInitializationOrderModuleList: LIST_ENTRY32;
    // etc...
  end;

  LDR_DATA_TABLE_ENTRY32 = record
    InLoadOrderLinks: LIST_ENTRY32;
    InMemoryOrderLinks: LIST_ENTRY32;
    InInitializationOrderLinks: LIST_ENTRY32;
    DllBase: ULONG;
    EntryPoint: ULONG;
    SizeOfImage: ULONG;
    FullDllName: UNICODE_STRING32;
    BaseDllName: UNICODE_STRING32;
    Flags: ULONG;
    // etc...
  end;
  
Смотрите, PEB_LDR_DATA.InLoadOrderModuleList.FLink указывает на LDR_DATA_TABLE_ENTRY.
По логике и PEB_LDR_DATA.InMemoryOrderModuleList.FLink должен указывать на LDR_DATA_TABLE_ENTRY, ибо об этом написано в MSDN.

Собственно пруф: ..\7.png

Однако это не соответствует действительности!
На самом деле каждый LIST_ENTRY указывает на самого себя в следующей структуре, а не на её начало, таким образом:
- PEB_LDR_DATA.InLoadOrderModuleList.FLink указывает на LDR_DATA_TABLE_ENTRY.InLoadOrderLinks (+0 от начала LDR_DATA_TABLE_ENTRY)
- PEB_LDR_DATA.InMemoryOrderModuleList.FLink указывает на LDR_DATA_TABLE_ENTRY.InMemoryOrderLinks (+ sizeof(LIST_ENTRY) от начала LDR_DATA_TABLE_ENTRY)
- PEB_LDR_DATA.InInitializationOrderModuleList.FLink указывает на LDR_DATA_TABLE_ENTRY.InInitializationOrderLinks (+ sizeof(LIST_ENTRY) * 2 от начала LDR_DATA_TABLE_ENTRY)
Проверьте это по картинке, я специально обозначил линки разными цветами, только красные стрелки идут в начало каждой структуры, синяя (означающая список InMemoryOrderLinks) идет со сдвигом, а зеленая, означающая InInitializationOrderLinks мало того что идет с еще большим сдвигом (т.к. она пропускает два двусвязных списка) так еще и всегда указывает на ntdll первым элементом списка, всегда пропуская исполняемый файл.


Для чтения данных загрузчика наиболее удобным будет InLoadOrderModuleList. Пишем код:

function TLoaderData.Scan64LdrData(LdrAddr: ULONG_PTR64): Integer;
var
  Ldr: PEB_LDR_DATA64;
  Entry: LDR_DATA_TABLE_ENTRY64;
  Module: TModuleData;
begin
  Result := 0;

  // читаем первичную структуру для определения начала списка
  if not ReadRemoteMemory(FProcess, LdrAddr,
    @Ldr, SizeOf(PEB_LDR_DATA64)) then
    Exit;

  LdrAddr := Ldr.InLoadOrderModuleList.FLink;

  // крутим цикл, пока не встретим завершающую структуру
  while (ReadRemoteMemory(FProcess, LdrAddr,
    @Entry, SizeOf(LDR_DATA_TABLE_ENTRY64))) and (Entry.DllBase <> 0) do
  begin
    Module.ImageBase := Entry.DllBase;
    Module.Is64Image := True;
    SetLength(Module.ImagePath, Entry.FullDllName.Length shr 1);
    if not ReadRemoteMemory(FProcess, Entry.FullDllName.Buffer,
      @Module.ImagePath[1], Entry.FullDllName.Length) then
    begin
      LdrAddr := Entry.InLoadOrderLinks.FLink;
      Continue;
    end;
	
	// ...
	
    FModuleList.Add(Module);
	
    LdrAddr := Entry.InLoadOrderLinks.FLink;
    Inc(Result);
  end;
end;

Вот так выглядит цикл чтения данных из списка 64 битного PEB->Ldr. Очень просто и компактно, условие выхода состоит из проверки завершающей структуры в списке, у которой все поля равны нулю (в данном случае проверка идет только по полю Entry.DllBase).
Но это для 64 бит, с которым никаких проблем не будет, а вот с 32 битами все намного хитрее. Дело в том что прямо сейчас мы не сможем нормально подгрузить список библиотек. Посмотрите самую первую картинку в начале главы, как вы думаете, откуда EnumProcessModulesEx брал информацию о модулях? Все верно, оттуда же откуда и мы сейчас, из списков загрузчика в удаленном процессе, и там, в этих списках для 32 битного PEB->Ldr все пути ведут к c:\windows\system32\ хотя по факту библиотеки грузятся совершенно по другому пути.
Как выкрутится из такой ситуации, будет показано в следующей главе, а сейчас, чтобы не мешать все в одну кучу, я покажу как можно решить эту проблему через применение небольшого костыля. Он нам нужен чтобы показать финальную работу класса, который мы написали в этой главе.

Итак, код чтения списка 32 битного загрузчика (вместе с костылем) будет выглядеть вот так (целиком код приводить не буду, он похож на чтение 64 бит).
Нам потребуется вот такой вспомогательный костыль, проверяющий - является ли файл на диске 32 битным:

  function IsFile32(const FilePath: string): Boolean;
  var
    DosHeader: TImageDosHeader;
    NtHeader: TImageNtHeaders32;
    Raw: TBufferedFileStream;
  begin
    Raw := TBufferedFileStream.Create(FilePath, fmShareDenyWrite);
    try
      Raw.ReadBuffer(DosHeader, SizeOf(TImageDosHeader));
      Raw.Position := DosHeader._lfanew;
      Raw.ReadBuffer(NtHeader, SizeOf(TImageNtHeaders32));
      Result := NtHeader.FileHeader.Machine = IMAGE_FILE_MACHINE_I386;
    finally
      Raw.Free;
    end;
  end;
  
а на место троеточия в коде выше встанет вот такой костыль:

    // нюанс, 32 битные библиотеки в списке LDR будут прописаны с путем из
    // дефолтной системной директории, хотя на самом деле они грузятся
    // из SysWow64 папки. Поэтому проверяем, если SysWow64 присутствует
    // то все 32 битные пути библиотек меняем на правильный посредством
    // вызова GetMappedFileName + нормализация.
    // Для 64 битных это делать не имеет смысла, т.к. они грузятся по старшим
    // адресам куда не может быть загружена 32 битная библиотека, а по младшим
    // мы и сами сможет прочитать данные из 32 битной сборки
    if FUse64Addr then
    begin
      // GetMappedFileName работает с адресами меньше MM_HIGHEST_USER_ADDRESS
      // если адрес будет больше - вернется ноль с ошибкой ERROR_INVALID_PARAMETER
      if Module.ImageBase < MM_HIGHEST_USER_ADDRESS then
      begin
        MapedFilePathLen := GetMappedFileName(FProcess, Pointer(Module.ImageBase),
          @MapedFilePath[1], MAX_PATH * SizeOf(Char));
        if MapedFilePathLen > 0 then
          Module.ImagePath := NormalizePath(Copy(MapedFilePath, 1, MapedFilePathLen));
      end
      else
      begin
        // а если адрес библиотеки выше допустимого, то будем делать костыль
        // проверка, находится ли файл в системной директории?
        if Module.ImagePath.StartsWith(Wow64Support.SystemDirectory, True) then
        begin
          // проверка, есть ли файл на диске и является ли он 32 битным?
          if not (FileExists(Module.ImagePath) and IsFile32(Module.ImagePath)) then
          begin
            // нет, файл отсутствует либо не является 32 битным
            // меняем путь на SysWow64 директорию
            Module.ImagePath := StringReplace(
              Module.ImagePath,
              Wow64Support.SystemDirectory,
              Wow64Support.SysWow64Directory, [rfIgnoreCase]);
            // повторная проверка
            if not (FileExists(Module.ImagePath) and IsFile32(Module.ImagePath)) then
              // если в SysWow64 нет подходящего файла, чтож - тогда пропускаем его
              // потому что мы его всеравно не сможем правильно подгрузить и обработать
              Module.ImagePath := EmptyStr;
          end;
        end;
      end;
    end;
	
	
Логика кода банальна, все что мы можем прочитать через штатный вызов GetMappedFileName, читаем через него (получая таким образом правильный путь к загруженной библиотеке).
Правда GetMappedFileName требует нормализации пути, т.к. возвращаемая им строка выглядит как "\Device\HarddiskVolume1\Windows\SysWOW64\ntdll.dll" и её надо привести в соответствие букве диска (но это мелочи).
А вот все что мы прочитать не можем, то тогда начинает работать костыль, в котором мы проверяем - действительно ли библиотека лежащяя в c:\windows\system32\ является 32 битной, и если нет - то проверяем, а есть ли такая же, но уже в syswow64, и если есть - то меняем путь на "правильный".

Ну и теперь давайте проверим как все это работает, допишем в тестовой консоли оставшийся код:

var
  Loader: TLoaderData;
  
  // полученые адреса загрузчика передаем лоадеру списков
  Loader := TLoaderData.Create(hProcess, IsWow64Mode);
  try
    Loader.Load32LoaderData(PEB32.LoaderData);
    Loader.Load64LoaderData(PEB64.LoaderData);
    Writeln(0, ': ', IntToHex(Loader.RootModule.ImageBase, 1), ' ', Loader.RootModule.ImagePath);
    for var I := 0 to Loader.Modules.Count - 1 do
      Writeln(I + 1, ': ', IntToHex(Loader.Modules[I].ImageBase, 1), ' ', Loader.Modules[I].ImagePath);	
  finally
    Loader.Free;
  end;  
  
..\8.png  
  
Результат совпал, код вывел все 27 модулей из списков загрузчика, пропустив только один загруженный C:\Windows\System32\en-US\kernel32.dll.mui
Но с ним как раз все нормально, т.к. данная библиотека не является исполняемой и отсутствует в списках загрузчика т.к. загружена с флагом LOAD_LIBRARY_AS_DATAFILE.

А теперь пришло время разбираться с костылем при чтении данных из 32 битного загрузчика