3. Вызов 64 битного кода из 32 битного

Еще раз напомню основной её тезис второй главы: в 64 битной OS нет 32 битных процессов. Есть только строго 64 битные, а вся 32 битность эмулируется посредством WOW64 подсистемы.
Когда вы вызываете какую либо API из своего 32 битного кода, управление ей передается не напрямую - происходит этап конвертации параметров в формат, который требует 64 битный аналог этой API и её прямой вызов.
Что за конвертация: тут все заключается в соглашении о вызовах. Как правило это STDCALL который в 32 битах требует передачи всех параметров через стэк, а вот в 64 битах STDCALL работает немного по другому, а именно он похож на вызов с соглашением FASTCALL где первые четыре параметра идут через регистры (RCX/RDX/R8/R9) а остальные через стек.
Но есть нюанс, напрямую вызвать 64-битный аналог нельзя. Дело в том что любой 32 битный код и 64 битный исполняются в разных контекстах!
Если вы откроете свой отладчик и перейдете в режим ассемблера, то увидите что селектор сегмента кода CS будет равен 0х23 (для 32 битного приложения), а если мы будем отлаживать 64 битное приложение, то контекст станет равен 0x33.

.\9.png

В зависимости от операционной системы такое переключение контекста делается разными способами, но все в итоге приходит к одному - вызову одной из этих инструкций
1. JMP FAR 0x33:addr
2. CALL FAR 0x33:addr
3. PUSH 0x33 + PUSH addr + RETF

Каждая из этих инструкций передает управление по указанному адресу с переключением сегмента кода на 64 бита (обратное переключение делается аналогично, только сегмент равен 0х23).
Давайте посмотрим все это на примере вызова функции NtQueryVirtualMemory() вызываемой в Windows 8.1 (на Windows 10 и выше картинка будет немного другая, но суть в итоге не изменится).

.\10.png

По шагам:
Функция начинается с инициализации регистра EAX некоей константой 0х22. Это так называемый SDT индекс (порядковый номер в таблице системных вызовов, или в оригинале - System Service Dispatch Table). Ну точнее как, на самом деле индекс занимает только младшее слово (16 бит), а вот старшее уже является вторым индексом для WDT (специальная таблица диспетчеризации Wow64 вызовов, о ней чуть позже).

Следующим шагом происходит вызов через сегмент FS с адресом 0xC0.
Cегмент FS в случае 32 битного кода всегда указывает на структуру Thread Environment Block (TEB), т.н. блок окружения потока (в 64 битах за это отвечает GS), а адрес 0xC0 указывает на смещение в этой структуре от её начала.
В MSDN полноценной документации по этой структуре вы не найдете, но (внезапно) она достаточно хорошо документирована в википедии:
https://en.wikipedia.org/wiki/Win32_Thread_Information_Block
Для 32 битного TEB этот оффсет указывает на поле Wow32Reserved, которое содержит в себе адрес функции KiFastSystemCall, состоящей из одной единственной инструкции JMP FAR

Инструкция KiFastSystemCall, выглядящая как JMP FAR 0x33:0x77C331A4 производит переключение селектора сегмента кода CS в 64 битный режим с выставлением значения 0х33 и передает управление на 64 битный код, в функцию CpupReturnFromSimulatedCode.
Не удивляйтесь такому странному названию функции, как я и говорил - в 64 битной Windows нет 32 битных процессов и эта функция означает что мы вернулись в родную среду из эмуляции 32 бит.

CpupReturnFromSimulatedCode, производит переключение на 64 битный стек и сохраняет состояние части регистров в CPUCONTEXT, после чего происходит передача управления функции TurboDispatchJumpAddressStart().

Именно в этой функции и происходит работа с старшей частью регистра EAX, которая была установлена еще на самом первом этапе.
Если вкратце - эта константа (старшая часть - на картинке выделена оранжевым) является индексом в т.н. Wow64 Dispatch Table (WDT) на которую указывает регистр R15. Комбинацией этих двух регистров (R15 + старшая часть EAX, перемещенная в ECX) из данной таблицы выбирается адрес обработчика, которому и передается управление (конвертация 32 битных параметров для вызова 64 битного аналога функции).
Точнее как, сама функция TurboDispatchJumpAddressEnd это такая большая вершимель кода обрабатывающая параметры вызываемой функции тем или иным способом, а вот WDT это в общем приближении аналог некоей таблицы switch-case которая располагается (как правило) чуть выше директории экспорта.
Win64Dbg даже показывает имена таких хэндлеров, вот я тут выписал несколько из них, чтобы было общее представление что каждый из них делает:

ServiceNoTurbo - расположен в самом начале TurboDispatchJumpAddressEnd (хэндлер по умолчанию для большинства вызовов)
Thunk0Arg
Thunk0ArgReloadState
Thunk1ArgSp
Thunk1ArgNSp
Thunk2ArgNSpNSp
...
Thunk4ArgSpNSpNSpNSpReloadState
Thunk4ArgNSpSpNSpNSp
Thunk4ArgSpSpSpNSp
ThunkNone - конец таблицы диспатча, прямой переход на INT3

.\11.png

Сам же SDT индекс NtQueryVirtualMemory содержится в младшей части этой некоей константы и равен он 0х22 - именно с этими параметрами и будет произведет вызов в ядро, что будет соответствовать своему 64 битному аналогу.

Конкретно для текущего вызова NtQueryVirtualMemory WDT индекс равен нулю, поэтому посредством таблицы диспетчеризации произойдет передача управления на хэндлер ServiceNoTurbo в результате чего будет произведен вызов Wow64SystemServiceEx.

И вот примерно такая же обвязка сделана для каждой 32-битной API функции, в том числе и для GetMappedFileName (а если точнее для NtQueryVirtualMemory которую она использует для своей работы).
Но минус в том, что все эти обработчики из WDT знают что их вызвали из 32 битного кода, а стало быть они точно знают что 64 битные указатели к ним прийти не могут.
А задача у нас, напомню (для решения проблемы, описанной во второй главе) вызвать полноценный 64 битный аналог функции (именно NtQueryVirtualMemory), передав в неё полноценный 64 битный указатель.

Поэтому мы не можем использовать вызов через TEB посредством сегмента FS, но это нам по сути и не нужно, так как: 
1. получать адрес 64 битной NTDLL мы умеем (код из второй главы)
2. получать адрес экспортируемой библиотекой функции мы также умеем (код из первой главы)

А значит надо разобраться с нюансами вызова 64 битных функций и по сути написать аналог Wow64SystemServiceEx (не полноценный, конечно, но аналог).

Итак, какие действия нам необходимо сделать.
1. Нужно контролировать стек. В 32 битах стек выравнивается по границе 4 байт, а вот в 64 битах он выровнен по границе 8 байт, поэтому перед передачей управления 64 битной функции нужно удостоверится в том что регистр ESP содержит правильное значение
2. Перевести 32 битные параметры лежащие на стеке (из-за соглашения STDCALL) в требуемые для 64 битного вызова. 
NtQueryVirtualMemory имеет шесть параметров https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntqueryvirtualmemory
Первые 4 параметра должны будут идти в регистрах RCX/RDX/R8/R9, остальные будут размещены на стеке, причем изначально все шесть параметров будут лежать на 32 битном стеке с оффсетом в 4 байта, а вот при переносе последних двух, нужно учитывать что они должны располагаться уже с учетом 8 байтного выравнивания.
3. Если нам нужно передать значения через регистры, можно воспользоваться стандартными EAX/EBX/ECX/EDX/ESI/EDI которые после переключения в 64 битный код преобразуются к RAX/RBX/RCX/RDX/RSI/RDI. Тоже будет работать и при обратном переключении, за исключением что старшие 32 бита каждого регистра будут отрезаны, т.е. мы сможем вытащить только младшую часть значения 64 битных регистров (а больше нам и не надо).

Ну чтож, давайте писать тестовый код. Заголовок функции будет выглядеть так:
 
function TestX64Switch(AnyParam: DWORD): Integer; stdcall;
asm
  // этот код будет сгенерирован дельфи автоматически  
  // ... пролог ...
  push ebp
  mov ebp, esp
  
  !!! следующая часть кода будет размещена здесь !!!  
  
  // ... и эпилог ...
  pop ebp
  ret $4
end;

Декларация соглашения stdcall и хотя бы один параметр заставит дельфи сгенерировать пролог и эпилог функции, используя который нам будет удобно обработать пункт первый из необходимых действий, а именно коррекцию стека по восьмибайтной границе.

Контроль выравнивания стека делается следующим кодом:

asm
  // выравниваем стек по 8-байтной границе
  
  mov eax, esp // берем текущее значение Stack Pointer
  and eax, 7   // нас интересует значение младших трех бит, отсекаем все лишнее
  cmp eax, 0   // проверяем - равно ли получившееся число нулю?
  je @stack_aligned

  // если не равно, тогда стек не выровнен, в EAX будет оффсет от ESP на сколько
  // сдвинулись данные в 32-битном стеке после правки значения ESP
  sub esp, eax

@stack_aligned:

  // отсюда работаем с выровненным по границе 8 байт стеком
 
  !!! следующая часть кода будет размещена здесь !!!
  
  // схлопываем фрейм стека нивелируя выравнивание по границе 8 байт
  // дальше отработает эпилог функции
  mov esp, ebp  
end;  

Из-за сгенерированного дельфи пролога и эпилога можно спокойно модифицировать регистр ESP без всяких последствий, главное в самом конце вернуть его значение к изначальному состоянию, каким оно было после пролога функции (а именно - равным EBP!), если все сделать правильно, после этого кода отработает штатный эпилог функции и значение стека восстановится до того состояния, каким оно было перед вызовом функции.

Переключение в 64 битный режим и выход из него будет выглядеть так:

  // переключение в 64 битный режим
  push $33                        // пишем новый сегмент кода
  db $E8, 0, 0, 0, 0              // call +5
  add [esp], 5                    // правим адрес возврата на идущий за retf
  retf // дальний возврат со сменой сегмента кода на CS:0х33 + адрес

  // начиная отсюда мы в 64 битном режиме!!!

  !!! следующая часть кода будет размещена здесь !!!

  // обратное переключение в 32 битный режим
  db $E8, 0, 0, 0, 0              // call +5
  mov [esp + 4], $23              // mov dword ptr [rsp + 4], $23
  add [esp], $0D                  // add dword ptr [rsp], $0D
  retf                            // дальний возврат со сменой сегмента кода на CS:0х23 + адрес
  
Данный код рассмотрим более подробно. Ключевой функцией здесь является RETF, именно она переключает сегментный селектор CS и передает управление на указанный адрес, причем оба этих значения должны быть расположены на стеке. И очень важный момент - она всегда работает с блоком строго 8 байт (сегмент+адрес), не важно из какого режима происходит вызов, из 32 бит или из 64.

Выглядит это следующим образом, допустим ESP у нас изначально равнялся 0x100 (для простоты)
1. push $33 - этим мы разместили 4 байта на стеке с новым значением селектора сегмента, при этом верхушка стека уменьшилась на эти 4 байта (ESP = 0xFC)
2. call +5 - (вызов реализован в виде опкодов, т.к. дельфи не позволяет написать такую инструкцию прямо в коде), данная инструкция размещает на стеке 4 байта в качестве адреса возврата, т.е. куда должно вернуться управление после завершения вызова, и переходит непосредственно на этот адрес (т.е. сдвигает регистр EIP ровно на указанные 5 байт, которые равны длине этой инструкции). Таким образом у нас на стеке лежат уже два числа, первое с контекстом, второе - адрес инструкции add (ESP = 0xF8)
3. add [esp], 5  - увеличивает значение адреса возврата на стеке, размещенное предыдущим вызовом на пять байт. Пять байт - это общая длина инструкций add[] (4 байта) и retf (1 байт), таким образом на стеке размещен адрес указывающий на следующую инструкцию после RETF (ESP не изменился)
4. retf - переключает селектор сегмента кода на значение расположенное по адресу [ESP + 4] и передает управление на адрес на который указывает [ESP], при этом увеличивает значение регистра ESP на использованные в качестве параметров 8 байт (в итоге ESP/RSP = 0x100)

И вот тут начинается самое интересное. Дельфи не знает что после RETF у нас выполняется 64 битный код и если мы попробуем поставить брякпойнт после инструкции RETF - ничего хорошего из этого не получится, поэтому лучше даже не пытайтесь. Отладку 64 битного кода нужно производить именно в 64 битах и только когда удостоверились что он написан правильно, только тогда его можно переносить внутрь данной функции тщательно контролируя по опкодам инструкций чтобы ничего не уплыло.

Впрочем теперь про выход из данного режима. Он выглядит практически идентично коду входа, за исключением одного момента. Т.к. вызов CALL происходит в 64 битном режиме, на стек сразу помещаются 8 байт и дополнительного PUSH уже не требуется, достаточно будет поправить только текущие значение, а именно [ESP + 4] теперь должен быть равен 0x23 а адрес возврата [ESP] нужно увеличить на 13 байт (длинна трех инструкций mov + add + retf)
Не стоит боятся того что после вызова CALL на стек изначально был размещен 8 битный указатель, т.к. он расположен в 32 битном участке кода старшие 32 бита (в которых расположен селектор) будут гарантировано равны нулю и их можно смело использовать.
