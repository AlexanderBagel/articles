3. Вызов 64 битного кода из 32 битного

Важно: вся третья глава будет про ассемблер и недокументированные подходы. В ней будет обьяснение реализации вызова 64 битной функции NtQueryVirtualMemory напрямую из 32 битного кода.
Если вы пока плаваете в ассемблере, просто пропускайте текущую главу и переходите к следующей.

Итак, еще раз напомню основной тезис второй главы: в 64 битной OS нет 32 битных процессов. Есть только строго 64 битные, а вся 32 битность эмулируется посредством WOW64 подсистемы.
Когда вы вызываете какую либо API из своего 32 битного кода, управление ей передается не напрямую - происходит этап конвертации параметров в формат, который требует 64 битный аналог этой API и её прямой вызов.
Что за конвертация: тут все заключается в соглашении о вызовах. Как правило это STDCALL который в 32 битах требует передачи всех параметров через стэк, а вот в 64 битах STDCALL работает немного по другому, а именно он похож на вызов с соглашением FASTCALL где первые четыре параметра идут через регистры (RCX/RDX/R8/R9) а остальные через стек.
https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention
Но есть нюанс, напрямую вызвать 64-битный аналог нельзя. Дело в том что любой 32 битный код и 64 битный исполняются в разных контекстах!
Если вы откроете свой отладчик и перейдете в режим ассемблера, то увидите что селектор сегмента кода CS будет равен 0х23 (для 32 битного приложения), а если мы будем отлаживать 64 битное приложение, то контекст станет равен 0x33.

.\9.png

В зависимости от операционной системы такое переключение контекста делается разными способами, но все в итоге приходит к одному - вызову одной из этих инструкций
1. JMP FAR 0x33:addr
2. CALL FAR 0x33:addr
3. PUSH 0x33 + PUSH addr + RETF

Каждая из этих инструкций передает управление по указанному адресу с переключением сегмента кода на 64 бита (обратное переключение делается аналогично, только сегмент равен 0х23).
Давайте посмотрим все это на примере вызова функции NtQueryVirtualMemory() вызываемой в Windows 8.1 (на Windows 10 и выше картинка будет немного другая, но суть в итоге не изменится).

.\10.png

По шагам:
Функция начинается с инициализации регистра EAX некоей константой 0х22. Это так называемый SDT индекс (порядковый номер в таблице системных вызовов, или в оригинале - System Service Dispatch Table). 
Ну точнее как, на самом деле SDT индекс занимает только младшее слово (16 бит), а вот старшее уже является вторым индексом для WDT (специальная таблица диспетчеризации Wow64 вызовов, о ней чуть позже).

Следующим шагом происходит вызов через сегмент FS с адресом 0xC0.
Cегмент FS в случае 32 битного кода всегда указывает на структуру Thread Environment Block (TEB), т.н. блок окружения потока (в 64 битах за это отвечает GS), а адрес 0xC0 указывает на смещение в этой структуре от её начала.
В MSDN полноценной документации по этой структуре вы не найдете, но (внезапно) она достаточно хорошо документирована в википедии:
https://en.wikipedia.org/wiki/Win32_Thread_Information_Block
Эта структура создается для каждого потока вашего приложения, причем в случае 32 битного приложения на 64 битной Windows, создается в двух экземплярах (32 и 64 бита соответственно).
Содержит кучу полезных для работы полей, допустим самое первое поле 32 битного TEB это указатель на верхушку SEH фреймов (текущей цепочки обработчиков исключений), через TEB реализованы все threadvar (точнее через поле TLS слотов) и прочее-прочее... Сейчас нас интересует поле Wow32Reserved, на которое указывает оффсет 0хС0, которое содержит в себе адрес функции KiFastSystemCall, состоящей из одной единственной инструкции JMP FAR

Инструкция KiFastSystemCall, выглядящая как JMP FAR 0x33:0x77C331A4 производит переключение селектора сегмента кода CS в 64 битный режим с выставлением значения 0х33 и передает управление на 64 битный код, в функцию CpupReturnFromSimulatedCode.
Не удивляйтесь такому странному названию функции, как я и говорил - в 64 битной Windows нет 32 битных процессов и эта функция означает что мы вернулись в родную среду из эмуляции 32 бит.

CpupReturnFromSimulatedCode, производит переключение на 64 битный стек и сохраняет состояние части регистров в CPUCONTEXT, после чего происходит передача управления функции TurboDispatchJumpAddressStart().

Именно в этой функции и происходит работа с старшей частью регистра EAX, которая была установлена еще на самом первом этапе.
Если вкратце - эта константа (старшая часть - на картинке выделена оранжевым) является индексом в т.н. Wow64 Dispatch Table (WDT) на которую указывает регистр R15. Комбинацией этих двух регистров (R15 + старшая часть EAX, перемещенная в ECX) из данной таблицы выбирается адрес обработчика, которому и передается управление (конвертация 32 битных параметров для вызова 64 битного аналога функции).
Точнее как, сама функция TurboDispatchJumpAddressEnd это такая большая вершимель кода обрабатывающая параметры вызываемой функции тем или иным способом, а вот WDT это в общем приближении аналог некоей таблицы switch-case которая располагается (как правило) чуть выше директории экспорта.
Если подгрузить отладочные символы, то можно увидеть имена обработчиков, вот я тут выписал несколько из них, чтобы было общее представление что каждый из них делает:

ServiceNoTurbo - расположен в самом начале TurboDispatchJumpAddressEnd (хэндлер по умолчанию для большинства вызовов)
Thunk0Arg
Thunk0ArgReloadState
Thunk1ArgSp
Thunk1ArgNSp
Thunk2ArgNSpNSp
...
Thunk4ArgSpNSpNSpNSpReloadState
Thunk4ArgNSpSpNSpNSp
Thunk4ArgSpSpSpNSp
ThunkNone - конец таблицы диспатча, прямой переход на INT3

.\11.png

Сам же SDT индекс NtQueryVirtualMemory содержится в младшей части этой некоей константы и равен он 0х22 - именно с этими параметрами и будет произведет вызов в ядро, что будет соответствовать своему 64 битному аналогу.

Конкретно для текущего вызова NtQueryVirtualMemory WDT индекс равен нулю, поэтому посредством таблицы диспетчеризации произойдет передача управления на хэндлер ServiceNoTurbo в результате чего будет произведен вызов Wow64SystemServiceEx.

Для справки: В Windows 10 и выше часть этих шагов изменена, в частности вызов через TEB заменен на аналогичную ему цепочку вызовов Wow64SystemServiceCall -> KiFastSystemCall, причем KiFastSystemCall теперь передает управление не напрямую в CpupReturnFromSimulatedCode, а определяет её адрес через WDT (такая вот оптимизация, видимо в будущем будут еще расширять).

И вот примерно такая же обвязка сделана для каждой 32-битной API функции, в том числе и для GetMappedFileName (а если точнее для NtQueryVirtualMemory которую она использует для своей работы).
Но минус в том, что все эти обработчики из WDT знают что их вызвали из 32 битного кода, а стало быть они точно знают что 64 битные указатели к ним прийти не могут.
А задача у нас, напомню (для решения проблемы, описанной во второй главе) вызвать полноценный 64 битный аналог функции (именно NtQueryVirtualMemory), передав в неё полноценный 64 битный указатель.

Вообще NtQueryVirtualMemory будет в этой статье эдаким краеугольным камнем вокруг которого все вертится.
Конкретно в статье она будет применяться для реализации следующих альтернатив (имеется ввиду функции, чьи 64 битные аналоги будут вызываться из 32 бит напрямую):
1. VirtualQueryEx - реализуется через вызов NtQueryVirtualMemory с флагом MemoryBasicInformation (равным нулю)
2. QueryWorkingSet - то же, только флаг MemoryWorkingSetList (равный единице)
3. GetMappedFileName - то же, только флаг MemoryMappedFilenameInformation (равный двойке)
Все эти функции (точнее их 64 битные аналоги), нужны для правильной работы с 64 битными указателями из 32 битного кода.

А сейчас надо разобраться с нюансами вызова 64 битных функций и по сути написать аналог Wow64SystemServiceEx (не полноценный, конечно, но аналог).

Итак, так как мы не можем использовать вызов через TEB посредством сегмента FS (по причине что там ждут от нас 32 битный указатель), нам нужно как-то определить адрес 64 битной функции в адресном пространстве нашего процесса.
Это мы уже умеем, так как:
1. мы знаем как получить адрес 64 битной NTDLL (код из второй главы)
2. мы знаем как получить адрес экспортируемой библиотекой функции (код из первой главы)

Какие действия еще необходимо сделать для нормального переключения в 64 бита и переноса результата обратно в 32.
1. Нужно контролировать стек. В 32 битах стек выравнивается по границе 4 байт, а вот в 64 битах он выровнен по границе 8 байт, поэтому перед передачей управления 64 битной функции нужно удостоверится в том что регистр ESP содержит правильное значение (грубо ESP mod 8 = 0).
Строго говоря нужно контролировать значения двух регистров ESP + EBP, но из-за особенностей формирования 64 битного стекового фрейма, достаточно будет проконтролировать только ESP, т.к. его значение будет передано в конечном итоге в RBP и оба регистра будут содержать уже выровненные значения.
2. Контролировать размеры теневого пространства (ShadowSpace) используемого для сброса регистров RCX/RDX/R8/R9. Данная область должна быть всегда выделена на стеке перед вызовом любой 64 битной stdcall функции, даже в случае когда она принимает меньшее количество параметров. В случае если количество параметров больше четырех, размер ShadowSpace расширяется на их размер.
3. Перевести 32 битные параметры лежащие на стеке (из-за соглашения STDCALL) в требуемые для 64 битного вызова. 
NtQueryVirtualMemory имеет шесть параметров https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntqueryvirtualmemory
Первые 4 параметра должны будут идти в регистрах RCX/RDX/R8/R9, остальные будут размещены на стеке, причем изначально все шесть параметров будут лежать на 32 битном стеке с оффсетом в 4 байта, а вот при переносе последних двух на 64 битный стек, нужно учитывать что они должны располагаться уже с учетом 8 байтного выравнивания.
4. Если нам нужно передать значения через регистры, можно воспользоваться стандартными EAX/EBX/ECX/EDX/ESI/EDI которые после переключения в 64 битный код преобразуются к RAX/RBX/RCX/RDX/RSI/RDI. Тоже будет работать и при обратном переключении, за исключением что старшие 32 бита каждого регистра будут отрезаны, т.е. мы сможем вытащить только младшую часть значения 64 битных регистров (а больше нам и не надо).
5. 8 байтовый 64 битный результат вполне укладывается в размер регистра RAX, но для передачи его в 32 бита нужно использовать пару EAX+EDX где EDX должен содержать старшие 32 бита RAX.

На этом список требований закончился, можно начинать писать код. Заголовок функции будет выглядеть так:

function NtQueryVirtualMemory64(FuncRVA: ULONG_PTR64; hProcess: THandle;
  BaseAddress: ULONG_PTR64; MemoryInformationClass: DWORD;
  MemoryInformation: Pointer; MemoryInformationLength: DWORD;
  ReturnLength: PULONG64): NTSTATUS; assembler; stdcall;
asm

end;
 
К списку параметров добавился адрес функции (первый параметр), остальные без изменения и соответствуют параметрам оригинальной функции.
Думаю с первым параметром все понятно - это адрес на который мы должны передать управление в 64 битном коде, и он равен реальному адресу NtQueryVirtualMemory в 64 битной NTDLL.
Обратите внимание что первый и третий параметр обьявлены как ULONG_PTR64. Это восьмибайтный тип, именно он будет заменять нам 64 битные указатели в 32 битном коде.
Декларация соглашения stdcall (и наличие хотя бы одного параметра) заставит дельфи сгенерировать пролог и эпилог функции, используя который нам будет удобно обработать пункт первый из необходимых действий, а именно коррекцию стека по восьмибайтной границе. Если вы прямо сейчас вызовите эту заглушку функции то пролог и эпилог (в CPU) будут выглядеть следующим образом:

asm
  // этот код будет сгенерирован дельфи автоматически  
  // ... пролог ...
  push ebp          // сохраняется база предыдущего стекового кадра
  mov ebp, esp      // инициализация базы новой верхушкой стека начинает таким образом новый стековый кадр
   
  // ... и эпилог ...
  pop ebp           // восстановление базы предыдущего стекового кадра
  ret $24           // возврат с коррекцией верхушки стека (ESP) 0х24 = пять параметров по 4 байта + 2 параметра по 8 байт
end;

Следующий шаг - добавляем контроль выравнивания 32 битного стека по границе 8 байт:

  mov eax, esp // берем текущее значение Stack Pointer
  and eax, 7   // нас интересует значение младших трех бит, отсекаем все лишнее
  cmp eax, 0   // проверяем - равно ли получившееся число нулю?
  je @stack_aligned

  // если не равно, тогда стек не выровнен, в EAX будет оффсет от ESP на сколько
  // сдвинулись данные в 32-битном стеке после правки значения ESP
  sub esp, eax

@stack_aligned:

  // отсюда работаем с выровненным по границе 8 байт стеком
  
  
Важный нюанс, т.к. у нас stdcall все параметры функции в текущий момент расположены на 32 битном стеке. Но т.к. мы выполняем коррекцию верхушки стека, необходимо знать на какое значение была произведена эта коррекция, чтобы потом из ESP/RSP получить правильные параметры. Именно за это и отвечает регистр EAX, который будет содержать в себе либо ноль (означающий что коррекция не производилась) либо другое число (должна быть четверка, но это не всегда обязательно). Конечно, можно было бы использовать регистр EBP как фиксированную точку, но нам предстоит переход в 64 битный режим, где так-же потребуется сформировать стековый фрейм, а он будет расположен относительно актуального значения ESP/RSP, так что EBP не подойдет.

Чтобы было более понятно то после контроля выравнивания стека у нас может быть два состояния:

.\12.png
  
Т.е. либо стек УЖЕ был выровнен и тогда коррекция значения ESP не требуется и оно будет равно значению EBP. Либо второй вариант - была произведена коррекция и значение ESP стало меньше EBP на какое-то значение (обычно на 4).
Главное тут понимать - 64 битный стек начнется ПОСЛЕ ESP, не важно, была подвижка его значения или нет.
    
Теперь следующий шаг - переключение в 64 битный режим:

  push $33                        // пишем новый сегмент кода
  db $E8, 0, 0, 0, 0              // call +5
  add [esp], 5                    // правим адрес возврата на идущий за retf
  retf // дальний возврат со сменой сегмента кода на CS:0х33 + адрес

  // начиная отсюда мы в 64 битном режиме!!!
  
Данный код рассмотрим более подробно. Ключевой функцией здесь является RETF, именно она переключает сегментный селектор CS и передает управление на указанный адрес, причем оба этих значения должны быть расположены на стеке. И очень важный момент - она всегда работает с блоком строго 8 байт (сегмент+адрес), не важно из какого режима происходит вызов, из 32 бит или из 64.

Выглядит это следующим образом, допустим ESP у нас изначально равнялся 0x100 (для простоты)
1. push $33 - этим мы разместили 4 байта на стеке с новым значением селектора сегмента, при этом верхушка стека уменьшилась на эти 4 байта (ESP = 0xFC)
2. call +5 - (вызов реализован в виде опкодов, т.к. дельфи не позволяет написать такую инструкцию прямо в коде), данная инструкция размещает на стеке 4 байта в качестве адреса возврата, т.е. куда должно вернуться управление после завершения вызова, и переходит непосредственно на этот адрес (т.е. сдвигает регистр EIP ровно на указанные 5 байт, которые равны длине этой инструкции). Таким образом у нас на стеке лежат уже два числа, первое с контекстом, второе содержит адрес инструкции add (стек теперь равен ESP = 0xF8)
3. add [esp], 5 - увеличивает значение адреса возврата на стеке, размещенное предыдущим вызовом на пять байт. Пять байт - это общая длина инструкций add[] (4 байта) и retf (1 байт), таким образом адрес размещенный на стеке изменился на адрес следующей инструкции после RETF (регистр ESP не изменился и остался равен ESP = 0xF8)
4. retf - переключает селектор сегмента кода на значение расположенное по адресу [ESP + 4] и передает управление на адрес на который указывает [ESP], при этом увеличивает значение регистра ESP на использованные в качестве параметров 8 байт (в итоге вершина стека стала равной изначальному значению, ESP/RSP = 0x100)

Как только выполнится RETF - начинается самое интересное. Дельфи не знает что после RETF у нас выполняется 64 битный код и если мы попробуем поставить брякпойнт после инструкции RETF - ничего хорошего из этого не получится, поэтому лучше даже не пытайтесь. Отладку 64 битного кода нужно производить именно в 64 битах и только когда удостоверились что он написан правильно, только тогда его можно переносить внутрь данной функции тщательно контролируя по опкодам инструкций чтобы ничего не уплыло.  
Впрочем (для отладки) можно взять 64 битный WinDbg - он умеет работать с кодом, который прыгает из 32 бит в 64 и обратно.
  
Теперь приступаем ко второму этапу, переводу параметров расположенных на 32 битном стеке в их 64 битный аналог и будет писать уже 64 битный код.

Для начала сформируем 64 битный стековый кадр:

  push ebp                              // push rbp
  db $48 sub esp, $30                   // sub rsp, $30
  db $48 mov ebp, esp                   // mov rbp, rsp
  
Вот тут такой... тонкий момент. Обратите внимание что я пишу вроде бы 32 битные инструкции, однако, так как в текущий момент этот код будет исполнятся в 64 битном режиме, то и интерпретироваться эти инструкции будут именно как 64 битные, в комментарии справа указано что именно будет выполнять процессор в этот момент. Единственный момент, это наличие префикса перед второй и третьей инструкцией ввиде db $48.
Это так называемый REX префикс. 
Грубо говоря каждая инструкция это набор опкодов выглядящих как префикс + опкод + ModRM + SIB ну и далее...
Вот поле ModRM у каждой инструкции (где оно присутствует) используется для 32 битной адресации, а REX префикс позволяет эту адресацию расширить.
Если убрать REX префикс то в 64 битном коде эти инструкции будут трактоваться абсолютно так-же как и в 32 битном, т.е. работа будет с регистрами ESP + EBP, а не RSP + RBP.
И хотя сейчас эти регистры содержат реально 32 битные значения, лучше писать все-же правильно (во избежание).
Можно конечно было их написать прямо через опкоды (DB/DW/DD) но такой вариант реализации мне показался более удобным.
  
Ну и если вернуться к стековому кадру - его наличие обязательно, т.к. согласно спецификации, не смотря на то что часть из шести параметров у вызываемой 64 битной NtQueryVirtualMemory пойдет через регистры, мы обязаны выделить под них место на стеке (т.н. ShadowSpace), этим и обусловлено наличие инструкции sub rsp, $30 (0х30 = 6 параметров * 8 байт)

Следующим шагом получим адрес последнего параметра расположенного на 32 битном стеке, а именно ReturnLength и тут нам потребуется немного математики.
Смотрите на картинку выше, ReturnLength изначально располагался по адресу EBP + 0x28.
Сам EBP равен значению ESP + коррекция в регистре EAX, т.е. ReturnLength = ESP + EAX + 0x28;
Дальше, мы поместили на стек значение RBP изменив регистр RSP (в который он преобразовался из ESP после переключения контекста) ровно на 8 байт, после чего зарезервировали место на 64 битном стеке еще под шесть восьмибайтных параметров. Добавляем эти 8 байт + 6 * 8 (всего 0x38) к константе, получается вот такой адрес - RSP + RAX + 0x60:

  db $48 lea eax, [esp + eax + $60]     // lea rax, [rsp + rax + $60]

Получив правильный адрес параметров на 32 битном стеке переносим последние два (ReturnLength + MemoryInformationLength) на 64 битный:

  // 1. ReturnLength
  mov ecx, [eax]                        // mov ecx, dword ptr [rax]
  db $48 mov [esp + $28], ecx           // mov [rsp + $28], rcx

  // 2. и размер данных "MemoryInformationLength"
  mov ecx, [eax - 4]                    // mov ecx, dword ptr [rax - 4]
  db $48 mov [esp + $20], ecx           // mov [rsp + $20], rcx
  
Смотрите, под 64 битные параметры зарезервировано 0х30 байт, ReturnLength самый последний, значит он должен быть расположен в последних восьми байтах, т.е. диапазон от 0x28 до 0x30.
Предпоследним на стек пойдет MemoryInformationLength со смещением 0x20 от начала зарезервированного стека.
И на этом со стеком все - осталось перенести оставшиеся 4 параметра в соответствующие регистры:

  // регистр R9 содержит указатель на память (MemoryInformation),
  // куда будет помещаться результат
  db $44 mov ecx, [eax - 8]             // mov r9d, dword ptr [rax - 8]

  // регистр R8 содержит идентификатор MemoryInformationClass
  db $44 mov eax, [eax - $C]            // mov r8d, dword ptr [rax - $С]

  // регистр RDX содержит BaseAddress
  db $48 mov edx, [eax - $14]           // mov rdx, [rax - $14]

  // RCX должен содержать hProcess
  mov ecx, [eax - $18]                  // mov ecx, dword ptr [rax - $18]
  
Обратите внимание что все параметры за исключением BaseAddress имеют размер 32 бита поэтому читаются именно как dword ptr[], при этом когда идет запись в регистр ECX (являющийся младшей частью RCX) старшая часть регистра RCX очищается. В этом большое отличие от работы с младшими частями регистра ECX, где при изменении CX/CL/CH старшая часть остается на месте.  
На текущий момент можно сказать что мы произвели все те-же самые подготовительные действия, которые выполняется в функции Wow64SystemServiceEx, поэтому раз у нас все готово, настал момент вызова 64 битной NtQueryVirtualMemory:
  
  call [eax - $20]                      // call [rax - $20]
  
Всё! Функция выполнилась, результат выполнения будет размещен в регистре RAX, который после переключения в 32 битный режим преобразуется в EAX, таким образом будет содержать в себе результат выполнения 64 битной функции и нам не нужно делать лишних телодвижений. 

Для возврата результата функции здесь в принципе будет достаточно того что вернется в регистре RAX, но чтоб быть последовательным все же желательно выполнить правильное преобразование в регистровую пару которую будет требовать 32 битный код в случае если будет возвращаться восьмибайтное значение:

  db $48 mov edx, eax                   // mov rdx, rax
  db $48, $C1, $EA, $20                 // shr rdx, $20

Младшая часть регистра RAX при переходе в 32 битный режим преобразуется в значение регистра EAX, а старшая часть, после этих двух строк будет перемещена в регистр EDX откуда его заберет вызываемый код (если это потребуется). Правда Delphi не позволяет записать инструкцию SHR в нормальном виде, поэтому она объявлена как набор опкодов.

Осталось только подчистить за собой:

  db $48 lea esp, [ebp + $30]           // lea rsp, [rbp + $30]
  pop ebp                               // pop rbp

Этими двумя строчками мы схлопываем 64 битный стековый кадр, он нам больше не нужен, можно переключаться обратно в 32 бита:  
  
  db $E8, 0, 0, 0, 0              // call +5
  mov [esp + 4], $23              // mov dword ptr [rsp + 4], $23
  add [esp], $0D                  // add dword ptr [rsp], $0D
  retf                            // дальний возврат со сменой сегмента кода на CS:0х23 + адрес
  
  // начиная отсюда мы опять в 32 битном режиме  

Выход выглядит практически идентично коду входа, за исключением одного момента. Т.к. вызов CALL происходит в 64 битном режиме, на стек сразу помещаются 8 байт и дополнительного PUSH уже не требуется, достаточно будет поправить только текущие значение, а именно [ESP + 4] теперь должен быть равен 0x23 а адрес возврата [ESP] нужно увеличить на 13 байт (длинна трех инструкций mov + add + retf)
Не стоит боятся того что после вызова CALL на стек изначально был размещен 8 битный указатель, т.к. он расположен в 32 битном участке кода старшие 32 бита (в которых расположен селектор) будут гарантировано равны нулю и их можно смело использовать.

Все что нам осталось это убрать возможные последствия коррекции верхушки стека, выставив регистру ESP значение равное EBP:

  mov esp, ebp
  
Это всё - дальше отработает эпилог функции который подчистит все что осталось и вернет управление вызывающему коду.

Теперь можно увидеть как выглядит функция целиком {ref}. Я специально её оставил в таком виде чтобы можно было её наглядно "пощупать" в отладчике.
В следующих главах вместо данной функции будет использоваться уже функция для автогенерации гейта {ref}, которая будет формировать динамически примерно такой-же код, как описано выше, только немного оптимизированный (с использованием JMP FAR и прямого CALL) и автоматически производить конвертацию 32 битных параметров в зависимости от их количества (т.е. её можно применять для генерации переходного гейта при вызове любой 64 битной функции с соглашением STDCALL, главное правильно указать количество и размеры её параметров и адрес).

Все что было описано выше имеет даже название (не я придумал) - Heavens Gate :)
Почему именно так, кто придумал и главное зачем - вопрос не ко мне.

Впрочем это был только первый шаг, теперь настало время применить эту функцию к коду из предыдущей главы чтобы убрать "костыль" и реализовать правильное определение пути загруженной библиотеки по её инстансу.
Один из нюансов работы с таким прямым вызовом 64 битной функции это то, что адрес буфера, в который функция пишет MemoryInformation всегда должен быть выровнен по границе 8 байт, поэтому чтобы не забывать о таком нюансе проще сразу написать универсальную обертку. Выглядеть она будет вот так:

function GetMappedFileName64(hProcess: THandle; lpv: ULONG_PTR64;
  lpFilename: LPCWSTR; nSize: DWORD): DWORD;
...
begin
{$IFDEF WIN32}
  Result := 0;
  if NtQueryVirtualMemoryAddr <> 0 then
  begin
    // структура TMappedFileName должна быть выровнена по 8-байтной границе
    // поэтому стек не используем, а выделяем принудительно
    MappedFileName := VirtualAlloc(nil,
      SizeOf(TMappedFileName), MEM_COMMIT, PAGE_READWRITE);
    try
      Status := NtQueryVirtualMemory64(NtQueryVirtualMemoryAddr, hProcess, lpv,
        MemoryMappedFilenameInformation, MappedFileName,
        SizeOf(TMappedFileName), @ReturnLength);

      if not NT_SUCCESS(Status) then
      begin
        BaseSetLastNTError(Status);
        Exit(0);
      end;

      nSize := nSize shl 1;
      cb := MappedFileName^.ObjectNameInfo.MaximumLength;

      if nSize < cb then
        cb := nSize;

      Move(MappedFileName^.FileName[0], lpFilename^, cb);

      if cb = MappedFileName^.ObjectNameInfo.MaximumLength then
        Dec(cb, SizeOf(WChar));

      Result := cb shr 1;

    finally
      VirtualFree(MappedFileName, SizeOf(TMappedFileName), MEM_RELEASE);
    end;
  end
  else
  {$ENDIF}
  Result := GetMappedFileName(hProcess, Pointer(lpv), lpFilename, nSize);
end;

Этот код практически один в один повторяет реализацию GetMappedFileName, только использует вызов NtQueryVirtualMemory64 для 32 бит в случае если снаружи был назначен её адрес.

Теперь мы можем подправить код в функции TLoaderData.Scan32LdrData {ref} удалив оттуда код "костыля" и заменив его на вот такой вызов:

    if FUse64Addr then
    begin
      MapedFilePathLen := GetMappedFileName64(FProcess, Module.ImageBase,
        @MapedFilePath[1], MAX_PATH * SizeOf(Char));
      if MapedFilePathLen > 0 then
        Module.ImagePath := NormalizePath(Copy(MapedFilePath, 1, MapedFilePathLen));
    end;
	
Последним шагом осталось инициализировать переменную содержащую адрес 64 битной NtQueryVirtualMemory, это делается вот таким кодом который должен быть вызван перед работой со списками загрузчика из второй главы {ref}: 

  if IsWow64Mode then
  begin
    LocalLoader := TLoaderData.Create(hProcess, True);
    try
      if LocalLoader.Load64LoaderData(PEB64.LoaderData) > 0 then
        for var Module in LocalLoader.Modules do
        begin
          if ExtractFileName(Module.ImagePath).ToLower = 'ntdll.dll' then
          begin
            Wow64Support.DisableRedirection;
            try
              NtDll := TRawPEImage.Create(Module.ImagePath, Module.ImageBase);
              try
                Index := NtDll.ExportIndex('NtQueryVirtualMemory');
                if Index >= 0 then
                  SetNtQueryVirtualMemoryAddr(NtDll.ExportList.List[Index].FuncAddrVA);
              finally
                NtDll.Free;
              end;
            finally
              Wow64Support.EnableRedirection;
            end;
            Break;
          end;
        end;
    finally
      LocalLoader.Free;
    end;
  end;
  
Задача данного кода:
1. через 64 битный список загрузчика определить инстанс NTDLL
2. загрузить её и получить адрес NtQueryVirtualMemory
3. назначить этот адрес служебной переменной
Шаги достаточно банальные, за исключением одного единственного нюанса, а именно - перед загрузкой NTDLL (конкретно перед вызовом TRawPEImage.Create) нужно ОБЯЗАТЕЛЬНО отключить редирект, в противном случае будет подгружена 32 битная ntdll из SysWow64 и адрес 64 битной функции будет определен не верно, в результате чего вызов NtQueryVirtualMemory64 будет всегда завершаться с AccessViolation внутри NTDLL.