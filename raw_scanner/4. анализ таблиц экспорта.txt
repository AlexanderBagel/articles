4. Обработка Forward деклараций и анализ таблиц экспорта

Перед тем как приступить к следующему шагу нужно выполнить некоторые подготовительные действия, чтобы потом на них не отвлекаться.
Первым делом, весь код из test.dpr из предыдущей главы, уходит в новый класс TRawScanner {ref}, задача которого выполнить подготовительные действия (создать нужные классы и выполнить инициализацию адреса 64 битной NtQueryVirtualMemory). Этот класс будет входной точкой, через которую будет вестись вся остальная работа с кодом (для удобства).
А также нужно сделать класс контейнер TRawModules {ref}, который будет хранить в себе список TRawPEImage и предоставлять методы для работы с ними.
Шлюз для вызова 64 битной NtQueryVirtualMemory заменен на универсальный гейт {ref} его код я рассматривать не буду, он просто более оптимизирован по сравнению с кодом шлюза из предыдущей главы и выполняет всю рутинную работу по подготовке среды окружения и конвертации параметров автоматически.

У центрального TRawScanner будет, помимо конструктора и деструктора, всего один основной метод InitFromProcess(PID), а также несколько свойств.
1. свойство Modules - которое будет представлять из себя класс TRawModules
2. свойство Analizer - новый класс анализатора, который будет реализован в этой главе.

Ну а TRawModules предоставляет методы для добавления новой библиотеки в общий список (функция AddImage), а также методы быстрого поиска библиотеки по её hInstance (функция GetModule), и быстрого получения информации по функции экспортируемой библиотекой (функция GetProcData)

  TRawModules = class
  private
    FItems: TObjectList<TRawPEImage>;
    FIndex: TDictionary<string, Integer>;
    FImageBaseIndex: TDictionary<ULONG_PTR64, Integer>;
  ...
  public    
    function AddImage(const AModule: TModuleData): Integer;
    procedure Clear;
    function GetModule(AddrVa: ULONG_PTR64): Integer;
    function GetProcData(const LibraryName, FuncName: string; Is64: Boolean;
      var ProcData: TExportChunk; CheckAddrVA: ULONG_PTR64): Boolean; overload;
    function GetProcData(const LibraryName: string; Ordinal: Word;
      Is64: Boolean; var ProcData: TExportChunk; CheckAddrVA: ULONG_PTR64): Boolean; overload;
    function GetProcData(const ForvardedFuncName: string; Is64: Boolean;
      var ProcData: TExportChunk; CheckAddrVA: ULONG_PTR64): Boolean; overload;	  
    property Items: TObjectList<TRawPEImage> read FItems;
  end;
  
Для реализации быстрой работы функций GetModule и GetProcData используется два словаря:
1. FIndex - словарь с ключом по имени библиотеки
2. FImageBaseIndex - словарь с ключом по hInstance библиотеки

Теперь вкратце что будет сделано в этой главе, общая задача выглядит так - имея на руках список загруженных модулей (как исполняемого файла, так и используемых им библиотек) произвести анализ всех доступных таблиц экспорта на предмет их соответствия рассчитанным значениям и вывести в лог измененные. Чтобы подстраховать самих себя потребуется небольшая функция, которая будет показывать - действительно ли были изменения по указанному адресу в удаленном адресном пространстве, или код анализатора ошибся.

Делается это при помощи API QueryWorkingSet https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-queryworkingset
Суть метода заключается в следующем, когда выделяется память, каждая страница памяти подгружается в общий пул, так называемый WorkingSet представляющий из себя список виртуальных страниц которые отображены на адресное пространство процесса (утрированно, находящихся в физической памяти, и хотя это не совсем так, но близко), где помимо адреса каждой страницы этот пул содержит информацию о текущих атрибутах защиты страницы (Protection), флаг - является ли страница доступной для совместного использования (Shared), а также количество процессов, совместно использующих данную страницу в текущий момент времени (SharedCount).

Когда процесс загружает библиотеку, для большинства из них (т.н. knowndlls) этап чтения образа библиотеки с диска пропускается и библиотека мапится в адресное пространство процесса как сегмент, ну это что-то типа кэширования для ускорения работы. И все страницы памяти, выделенные под библиотеку помечаются как общедоступные, т.е. одну и туже страницу (но только в режиме чтения) может использовать несколько процессов одновременно.
В случае если грузится обычная библиотека (ну, например, разработанная вами самостоятельно) в этом случае уже идет её реальное чтение с диска, НО даже после этого, все её страницы помечаются как общедоступные. 

Так вот, как только будет произведена попытка записи в любую из общедоступных страниц, будет создана копия этой страницы и все изменения будут отображены только в данной копии, а сама страница конечно будет отсоединена от механизма совместного использования, со сбросом флагов Shared и SharedCount. Вот именно это и будет определяться в качестве подстраховки.

Вообще (в качестве справочной информации) QueryWorkingSet достаточно часто используется в антиотладке, позволяя помимо определения изменений страниц памяти детектировать работу сканеров памяти, которые не производят изменений, а просто ищут что-то в нашем процессе.
Это делается в два этапа:
1. Выделяем контрольную страницу через VirtualAlloc и запоминаем её адрес где-либо.
2. Сбрасываем ворксет вызовом SetProcessWorkingSetSize указав вторым и третьим параметров значение "SIZE_T(-1)"
После этого страница будет выгружена из рабочего набора и появится в нем только тогда, когда кто-то попробует её прочитать.
Так как сами мы читать её не собираемся, её появление в ворксете после очередной проверки (допустим по таймеру) может означать только одно - нас сканируют снаружи!

Теперь к реализации - эта функция работает через реализованную в предыдущей главе NtQueryVirtualMemory передавая ей в качестве флага MemoryWorkingSetList равный единице. Если мы вызовем QueryWorkingSet из 32 битного кода, то результатом будет информация только по страницам памяти доступным из 32 бит (до лимита в MM_HIGHEST_USER_ADDRESS), а так как нас интересует полный диапазон страниц, то вызывать нужно именно её 64 битный аналог (точнее 64 битную NtQueryVirtualMemory).
Нюанс с вызовом NtQueryVirtualMemory в том что т.к. это 64 битная функция, то и все адреса, которые она принимает на вход, должны соответствовать значениям, которые может принять 64 битный указатель, т.е. все эти адреса должны быть выравнены по границе 8 байт, в противном случае NtQueryVirtualMemory вернет STATUS_DATATYPE_MISALIGNMENT. Чтобы не забыть про этот нюанс и не контролировать каждый вызов используется промежуточная обертка:

{$IFDEF WIN32}
function InternalNtQueryVirtualMemory64(FuncRVA: ULONG_PTR64; hProcess: THandle;
  BaseAddress: ULONG_PTR64; MemoryInformationClass: DWORD;
  MemoryInformation: Pointer; MemoryInformationLength: DWORD;
  ReturnLength: PULONG64): NTSTATUS;
var
  AlignedBuff: Pointer;
begin
  AlignedBuff := VirtualAlloc(nil,
    MemoryInformationLength, MEM_COMMIT, PAGE_READWRITE);
  try
    Result := NtQueryVirtualMemory64(FuncRVA, hProcess, BaseAddress,
      MemoryInformationClass, AlignedBuff, MemoryInformationLength,
      ReturnLength);
    Move(AlignedBuff^, MemoryInformation^, MemoryInformationLength);
  finally
    VirtualFree(AlignedBuff, MemoryInformationLength, MEM_RELEASE);
  end;
end;
{$ENDIF}

Внутри данной обертки нет проверки результата и AlignedBuff всегда копируется в результирующий буфер MemoryInformation. 
Дело в том что штатными кодами ошибок для этой функции, помимо STATUS_SUCCESS является допустим и STATUS_INFO_LENGTH_MISMATCH, который означает что не хватает размера выделенного буфера, при этом требуемый размер будет размещен в AlignedBuff и его нужно вернуть вызывающему коду.

Сама же реализация функции выглядит вот так:

function QueryWorkingSet64(hProcess: THandle; pv: Pointer; cb: DWORD): Boolean;
{$IFDEF WIN32}
const
  MemoryWorkingSetList = 1;
var
  Status: NTSTATUS;
{$ENDIF}
begin
  {$IFDEF WIN32}
  if not Wow64Support.Use64AddrMode then
  begin
    Result := QueryWorkingSet32(hProcess, pv, cb);
    Exit;
  end;
  if NtQueryVirtualMemoryAddr <> 0 then
  begin
    Status := InternalNtQueryVirtualMemory64(NtQueryVirtualMemoryAddr,
      hProcess, 0, MemoryWorkingSetList, pv, cb, nil);
    if NT_SUCCESS(Status) then
      Exit(True);
  end;
  Result := False;
  {$ELSE}
  Result := QueryWorkingSet(hProcess, pv, cb);
  {$ENDIF}
end;

В ней вначале идет проверка, если мы находимся под чистой 32 битной ОС, то происходит вызов функции QueryWorkingSet32, которая делает вызов нативной QueryWorkingSet с преобразованием результата вызова в массив 64 битных указателей.
В противном случае вызываем 64 битную NtQueryVirtualMemory с флагом MemoryWorkingSetList.

С подготовительными действиями закончили, пришло время писать код анализатора. В новом модуле RawScanner.Analyzer пишем класс:

  TPatchAnalyzer = class  
  private
    ...
    function CheckPageSharing(AddrVa: ULONG_PTR64;
      out SharedCount: Byte): Boolean;
  protected
    procedure DoModifyed(HookData: THookData);
    procedure InitWorkingSet;    
    procedure ScanExport(Index: Integer; Module: TRawPEImage);
    procedure ScanModule(Index: Integer);
  public
    constructor Create(AProcessHandle: THandle; ARawModules: TRawModules);
    destructor Destroy; override;
    function Analyze(
      AProcessTableHook: TProcessTableHookCallBack;
      AProcessCodeHook: TProcessCodeHookCallBack): TAnalizeResult;
  end;
  
Полностью его рассматривать я не буду, опишу только общий принцип и узкие моменты.
В конструктор класса приходит хэндл открытого процесса и список модулей для анализа (подготовленный классом TRawScanner). Хэндл потребуется для работы QueryWorkingSet64, ну а список - именно по нему и будет идти анализ.

Единственным методом доступным снаружи является функция Analyze, которая параметрами принимает два калбэка реализованных во внешне коде, и именно они будут вызываться в том случае, если анализатор обнаружил какие то нарушения в памяти удаленного процесса. Задача данного метода инициализировать WorkingSet процесса вызовом процедуры InitWorkingSet после чего в цикле вызвать для каждого модуля из списка TRawModules процедуру ScanModule.

ScanModule в свою очередь загружает в память образ сканируемого модуля (в TMemoryStream) и вызывает ScanExport.
И вот ScanExport нужно рассмотреть более подробно. Задача данной процедуры состоит в контроле целостности таблицы экспорта в удаленном адресном пространстве, сравнением значений записанных в ней с заранее рассчитанными.

Если немножко подсократить код функции, то основная её часть выглядит вот так:

procedure TPatchAnalyzer.ScanExport(Index: Integer; Module: TRawPEImage);
begin
  ExportDirectory := TRemoteStream.Create(FProcessHandle,
    Module.ExportDirectory.VirtualAddress, Module.ExportDirectory.Size);
  try
    ZeroMemory(@HookData, SizeOf(THookData));
    ... инициализация структуры
    for Exp in Module.ExportList do
    begin
      ...	  
	  HookData.RawVA := Exp.FuncAddrVA;
      ...	  
      if not ExportDirectory.ReadMemory(Exp.ExportTableVA, 4,
        @HookData.ExportAdv.ExpRemoteRva) then
        Continue;
		
      HookData.RemoteVA :=
        HookData.ExportAdv.ExpRemoteRva + Module.ImageBase;

      if HookData.RemoteVA <> HookData.RawVA then
      begin

        if Exp.ForvardedTo <> EmptyStr then
          if not FRawModules.GetProcData(Exp.ForvardedTo,
            Module.Image64, ForvardedExp, HookData.RemoteVA) then
          begin
            HookData.Calculated := False;
            DoModifyed(HookData);
            Continue;
          end
          else
            HookData.RawVA := ForvardedExp.FuncAddrVA;

        if HookData.RemoteVA <> HookData.RawVA then
        begin
          DoModifyed(HookData);
          Continue;
        end;
      end;
    end;
  finally
    ExportDirectory.Free;
  end;
end;

Первым идет вызов TRemoteStream.Create - это простенький класс представляющий из себя обертку над TMemoryStream и выступающий в качестве кэша, т.к. в процессе анализа будет много чтений памяти удаленного процесса, чтобы не вызывать на каждый чих ReadRemoteMemory вся память, из которой теоретически будет происходить чтение, сразу копируется в этот класс за один присест.

Следующим шагом идет основной цикл в котором мы последовательно идем по каждой записи из таблицы экспорта переданного на вход модуля Module.ExportList, при этом для каждой записи заполняется структура, которую в случае обнаружения несовпадений будет отдаваться наружу в калбэк, для последующей обработки внешним кодом.

Для каждой записи читается RVA адрес экспортируемой функции через (рассчитанный еще в TRawPEImage адрес в таблице экспорта) Exp.ExportTableVA, после чего прочитанный RVA адрес переводится в VA сложением с базой текущего модуля ImageBase (ну т.е. с его hInstance).
И делается проверка - если полученное значение не равно тому, которое рассчитал наш код еще в классе TRawPEImage (вторая глава) то это может означать три варианта:
1. код расчета "правильного" значения ошибочен
2. код в таблице экспорта действительно пропатчен и ведет на установленный извне перехватчик.
3. экспортируемая функция перенаправлена и её реализация находится в другом модуле

Первый вариант рассматривать не буду - код правильный (но это не точно).
Второй вариант вполне допустим, но как правило первое сравнение не успешно по причине форварда, т.е. перенаправления адреса функции на совершенно другой модуль. Поэтому следующим шагом происходит поиск адреса перенаправленной функции и если получилось его найти - повторное сравнение.
Ну а если и в этом случае адреса не совпали, тогда уже вызывается внешний обработчик через DoModifyed.

Вот именно в процедуре DoModifyed происходит проверка шаринга страницы через вызов функции CheckPageSharing и заполнение результата в структуре, отдаваемой в калбэк. В ней есть нюанс, поэтому рассмотрим её код поподробней:

function TPatchAnalyzer.CheckPageSharing(AddrVa: ULONG_PTR64;
  out SharedCount: Byte): Boolean;
begin
  Result := FWorkingSet.TryGetValue(AddrVA and PageMask, SharedCount);
  if not Result then    
    if ReadRemoteMemory(FProcessHandle, AddrVa, @Tmp, 1) then
    begin
      InitWorkingSet;
      Result := FWorkingSet.TryGetValue(AddrVA and PageMask, SharedCount);
    end;      
end;

Здесь происходит следующее, сначала происходит попытка найти информацию о странице, к которой принадлежит адрес, в текущем пуле страниц ворксета, при этом (т.к. грануляция страниц 4096 байта), применяется маска отсекающая младшую часть адреса.
А вот если страница не нашлась, то происходит попытка её подгрузки в ворксет чтением одного байта по указанному адресу (чуть выше я рассказывал про детект сканера памяти, вот тут тоже самое) в результате чего (если получилось прочитать) повторно перестраиваем ворксет и еще раз пытаемся получить информацию по странице.

Так вот, как только мы нашли не совпадение, вызывается калбэк, назначенный во внешнем коде, в который передается информация ввиде структуры с параметрами описывающими, что именно наш анализатор нашел и что ему не нравится. Реализацию калбэка я рассматривать не буду, он достаточно тривиальный и основная его задача - это вывод результата в форматированном виде. Код колбэка и вспомогательных функций находится в модуле "display_utils.pas" {ref}

Давайте посмотрим как это все будет работать. В коде демопримера я специально ввел дефайн, чтобы вы смогли посмотреть как будет работать код на текущий момент времени, при еще не реализованной обработке форвард деклараций функций. 
Для этого раскоментируйте директиву DISABLE_FORWARD_PROCESSING в инклуде "defines.inc".

.\13.png

Вот они все, четыре функции из user32.dll (скриншот снят на Windows 11, на других ОС список функций может быть другим).
Анализатор показал что адреса всех четырех функций ведут вместо библиотеки user32 (которая их экспортирует) куда-то внутрь ntdll.dll

Чтобы было понятней что именно выводит анализатор, то разьясню:
1. сначала пишется тип перехвата (Export/Import/Delay Import), далее имя библиотеки и фунции
2. далее идет контрольный статус получаемый через контроль шаринга страницы. Status: PATCHED означает что страница была модифицирована.
3. Expected: HEX_VALUE - ожидаемый адрес экспортируемой функции
4. present: HEX_VALUE - текущий адрес экспортируемой функции (если получилось определить - пишется имя модуля которому принадлежит этот адрес)
5. в заголовке таблицы поле Raw (0xHEX_VALUE) - смещение от начала файла где содержится RVA адрес экспортируемой функции
6. в последней строке VA адрес в таблице экспорта с записью об функции, её значение в оригинальном файле и значение в удаленном адресном пространстве

Можно посмотреть как выглядит таблица экспорта user32.dll через сторонний инструмент и там увидеть вот такую картинку:

.\14.png

Да, каждая из показанных четырех функций действительно перенаправлена, рассмотрим вот эту строчку вывода анализатора поподробней:

Export modified user32.dll -> DefDlgProcA. Status: PATCHED!
Expected: 0000000076F2A133, present: 0000000077B884A0 --> ntdll.dll
Addr:           |Raw (0xA61C4):                                            |Remote:
----------------------------------------------------------------------------------------------------------------------------
0000000076F26DC4|33 A1 0A 00                                               |A0 84 D0 00

и будем сверять её с текущей записью в таблице экспорта:

76F26DC4: A0 84 D0 00      EAT FuncAddr [1669] user32.dll!DefDlgProcA -> NTDLL.NtdllDialogWndProc_A = [77B884A0]

1. адрес 76F26DC4 - анализатор правильно определил адрес записи в таблице экспорта и показал что текущее значение "A0 84 D0 00" не соответствует рассчитанному.
2. "present: 0000000077B884A0 --> ntdll.dll" анализатор правильно определил текущий адрес функции и он соответствует "NTDLL.NtdllDialogWndProc_A = [77B884A0]" на которую произошло перенаправление.
3. "Expected: 0000000076F2A133" а давайте посмотрим что хранится по адресу, который ожидал анализатор.

А там...

.\15.png

А там строка "NTDLL.NtdllDialogWndProc_A"!!! Причем адрес этой строки находится в директории экспорта.
Собственно - это все что нужно знать про перенаправление, серьезно :)
Ну а если без шуток, то действительно у большинства функций RVA адрес в таблице экспорта ведет куда-то внутрь секции кода этого же модуля, и только у перенаправленых функций он ведет на строку в директории экспорта, т.е. по факту такую проверку форварда можно сделать прямо в TRawPEImage:

function TRawPEImage.IsExportForvarded(RvaAddr: DWORD): Boolean;
begin
  Result := DirectoryIndexFromRva(RvaAddr) = IMAGE_DIRECTORY_ENTRY_EXPORT;
end;

И этого будет вполне достаточно. 
Вообще конечно с форвардом это они удачно придумали, можно спокойно переносить ранее реализованные куски код тасуя их между модулями причем без потери совместимости, только нужно учитывать что функция, на которую произошло перенаправление, сама может быть перенаправлена!
Пример такой функции (нашлось в Win11): USP10.ScriptGetLogicalWidths -> GDI32.ScriptGetLogicalWidths -> gdi32full.ScriptGetLogicalWidths
И при расчете адреса экспортируемой функции (точнее значения, которое должно быть записано в таблице экспорта) форвард нужно учитывать обязательно.

Осталось только реализовать обработку, это делается буквально добавлением нескольких строк кода в класс TRawPEImage (ориентируйтесь на директиву DISABLE_FORWARD_PROCESSING).

Выглядят они вот так:

      {$IFNDEF DISABLE_FORWARD_PROCESSING}
      if IsExportForvarded(FunctionsAddr[ExportChunk.Ordinal]) then
      begin
        Raw.Position := ExportChunk.FuncAddrRaw;
        if Raw.Position = 0 then Continue;
        ExportChunk.OriginalForvardedTo := ReadString(Raw);
        ProcessApiSetRedirect(FOriginalName, ExportChunk);
      end
      else
      begin
        ExportChunk.OriginalForvardedTo := EmptyStr;
        ExportChunk.ForvardedTo := EmptyStr;
      end;
      {$ENDIF}
	  
Т.е. проверяем через показанную выше IsExportForvarded, является ли запись об экспорте перенаправленной, и если да - читаем строку форварда.
Этот же код нужно продублировать чуть ниже, где обрабатываются функции экспортирующиеся по ординару.

Пора переходить к таблице импорта, где помимо форвард деклараций функций появляются редиректы...