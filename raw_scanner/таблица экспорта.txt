1. таблица экспорта

В данной главе разберем принцип получения адресов экспортируемых исполняемым файлом (или библиотекой) функций, читая эту информацию напрямую из образа на жестком диске. Вся эта информация хранится в таблице экспорта, поэтому с неё и начнем. 
Данная таблица применяется в случае динамической линовки функций посредством LoadLibrary + GetProcAddress, а так-же для заполнения информации в таблицах импорта и отложенного импорта загружаемых библиотек (на этом пока не акцентируйте внимание).

Я не буду сильно углубляться по формату РЕ файла, благо на эту тему есть огромное количество статей, поэтому описывать буду только интересующие для текущей задачи моменты.

Итак, выход на таблицу импорта происходит посредством чтения трех структур, которые всегда присутствуют в начале любого РЕ файла.
1. Чтением структуры IMAGE_DOS_HEADER, с которой начинается исполняемый файл
2. Переходом на смещение IMAGE_DOS_HEADER._lfanew, указывающий на начало PE заголовка
3. Проверкой наличия четырехбайтной сигнатуры IMAGE_NT_SIGNATURE и чтением идущей за ней структуры IMAGE_FILE_HEADER
4. Из этой структуры будут интересны два поля. NumberOfSections и Machine. В зависимости от значения второго нужно прочитать идущую следом
4.1 либо структуру IMAGE_OPTIONAL_HEADER32 в случае если IMAGE_FILE_HEADER.Machine = IMAGE_FILE_MACHINE_I386
4.2 либо структуру IMAGE_OPTIONAL_HEADER64 в случае если IMAGE_FILE_HEADER.Machine = IMAGE_FILE_MACHINE_AMD64

Вот примерно так, как на картинке ..\1.png

Различия структур IMAGE_OPTIONAL_HEADER друг от друга заключается в размере полей. 
32 битная содержит 4 байтные DWORD, а 64 битная восьмибайтные ULONGLONG.
Последним полем IMAGE_OPTIONAL_HEADERхх содержит массив IMAGE_DATA_DIRECTORY (всего 16 элементов). Вот именно он нас и интересует, а если конкретнее, то самый первый его элемент обозначающийся индексом IMAGE_DIRECTORY_ENTRY_EXPORT.
Но прежде чем начать работу с этим массивом, необходимо прочитать и запомнить данные о секциях исполняемого файла. Их количество мы прочитали ранее в IMAGE_FILE_HEADER.NumberOfSections, и представляют они из себя массив структур IMAGE_SECTION_HEADER которые идут сразу после IMAGE_OPTIONAL_HEADERхх.

Что из себя представляет структура IMAGE_DATA_DIRECTORY[IMAGE_DIRECTORY_ENTRY_EXPORT]? 
Это всего два поля: 
1. VirtualAddress (DWORD) - RVA адрес директории
2. Size (DWORD) - её размер

Да, сразу же оговорюсь, в данной статье будут применяться три термина относительно адресации:
1. RAW адрес - смещение от начала файла на диске (всегда 4 байта).
2. RVA адрес (relative virtual address), это относительный адрес в том виде, в котором он записан в исполняемом файле (всегда 4 байта).
3. VA адрес - реальный адрес в адресном пространстве процесса. Т.к. нам нужно работать и с 32 битами и с 64, то он хранится в виде 8-байтного ULONG_PTR64 (UInt64), но содержит в зависимости от битности процесса либо 32 битный указатель, либо 64 битный. VA адрес (как правило) рассчитывается исходя из базы загрузки файла IMAGE_OPTIONAL_HEADERхх.ImageBase и прибавления к ней RVA адреса, но могут быть и исключения (например структуры ApiSet таблиц, которые рассмотрим немного позже, содержат RVA адреса относительно своего заголовка, а не ImageBase. Тоже относится к спискам контекста активации процесса где два соседних поля структуры вообще могут идти с разной базой, их упомяну вскользь ближе к концу статьи).

В дополнение к IMAGE_DATA_DIRECTORY, структура описывающая секцию (IMAGE_SECTION_HEADER) предоставляет следующий набор интересующих нас полей.
1. VirtualAddress (DWORD) - RVA адрес секции
2. VirtualSize (DWORD) - её размер в адресном пространстве процесса
3. PointerToRawData (DWORD) - RAW адрес секции
4. SizeOfRawData (DWORD) - размер RAW данных в файле

Так вот, если мы создадим пустое консольное приложение и выполним над ним описанные выше шаги, то увидим что у нас на руках будет структура с такими параметрами:
IMAGE_DATA_DIRECTORY[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = 0x103000
IMAGE_DATA_DIRECTORY[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = 0x96

В данном случае я говорю про Delphi 10.4, которая создает исполняемые файлы с тремя экспортируемыми функциями:
dbkFCallWrapperAddr, _dbk_fcall_wrapper и TMethodImplementationIntercept 

Чтобы прочитать данные таблицы экспорта из файла, полученный RVA адрес 0x103000 не подходит и нужно его пересчитать в RAW и вот именно тут нам пригодятся данные из массива IMAGE_SECTION_HEADER, который содержит данные для преобразования из одного типа указателя в другой.
Начинаем писать код. Создадим новый класс TRawPEImage {линк}, этапы чтения структур заголовка (LoadFromImage + LoadNtHeader) и секций (LoadSections) я пропущу, отмечу только один нюанс.
Так как подразумевается работа с 64 битным кодом из 32 битного приложения, то поле FNtHeader в данном классе имеет тип TImageNtHeaders64 и при чтении 32 битного заголовка происходит этап конвертации 32 битного опционального заголовка в 64. Это сделано только для удобства работы.

Начнем сразу с реализации утилитарных функций. Первые две функции выглядит так:

function TRawPEImage.RvaToVa(RvaAddr: DWORD): ULONG_PTR64;
begin
  Result := FImageBase + RvaAddr;
end;

function TRawPEImage.VaToRva(VaAddr: ULONG_PTR64): DWORD;
begin
  Result := VaAddr - FImageBase;
end;

Собственно это и есть все преобразование из RVA адресации в VA и наоборот, но третья функция будет выглядеть гораздо сложнее.
Для преобразования из RVA адреса в RAW нам потребуется три вспомогательных функции.

function TRawPEImage.AlignDown(Value, Align: DWORD): DWORD;
begin
  Result := Value and not DWORD(Align - 1);
end;

function TRawPEImage.AlignUp(Value, Align: DWORD): DWORD;
begin
  if Value = 0 then Exit(0);
  Result := AlignDown(Value - 1, Align) + Align;
end;

Эти две функции отвечают за выравнивание, а третья отвечает за поиск секции к которой принадлежит RVA адрес:

function TRawPEImage.GetSectionData(RvaAddr: DWORD;
  var Data: TSectionData): Boolean;
var
  I, NumberOfSections: Integer;
  SizeOfRawData, VirtualSize: DWORD;
begin
  Result := False;

  NumberOfSections := Length(FSections);
  for I := 0 to NumberOfSections - 1 do
  begin

    if FSections[I].SizeOfRawData = 0 then
      Continue;
    if FSections[I].PointerToRawData = 0 then
      Continue;

    Data.StartRVA := FSections[I].VirtualAddress;
    if FNtHeader.OptionalHeader.SectionAlignment >= DEFAULT_SECTION_ALIGNMENT then
      Data.StartRVA := AlignDown(Data.StartRVA, FNtHeader.OptionalHeader.SectionAlignment);

    SizeOfRawData := FSections[I].SizeOfRawData;
    VirtualSize := FSections[I].Misc.VirtualSize;

    // если виртуальный размер секции не указан, то берем его из размера данных
    // (см. LdrpSnapIAT или RelocateLoaderSections)
    // к которому уже применяется SectionAlignment
    if VirtualSize = 0 then
      VirtualSize := SizeOfRawData;

    if FNtHeader.OptionalHeader.SectionAlignment >= DEFAULT_SECTION_ALIGNMENT then
    begin
      SizeOfRawData := AlignUp(SizeOfRawData, FNtHeader.OptionalHeader.FileAlignment);
      VirtualSize := AlignUp(VirtualSize, FNtHeader.OptionalHeader.SectionAlignment);
    end;
    Data.Size := Min(SizeOfRawData, VirtualSize);

    if (RvaAddr >= Data.StartRVA) and (RvaAddr < Data.StartRVA + Data.Size) then
    begin
      Data.Index := I;
      Result := True;
      Break;
    end;

  end;
end;

В ней происходит перебор секций, и первым этапом идет пропуск секций с нулевым размером или отсутствующими данными.
Вторым этапом вычисляется нижняя граница секции (её начало) на основе VirtualAddress с округлением вниз на значение SectionAlignment.
Третьим - верхняя граница (её конец) на основе сначала Misc.VirtualSize с округлением вверх на значение SectionAlignment, а потом SizeOfRawData с округлением вверх на значение FileAlignment.
Важный нюанс, Misc.VirtualSize может быть равен нулю и это штатное значение, в таком случае в качестве конечного адреса секции берется значение из SizeOfRawData к которому также применяется округление вверх, но уже на значение SectionAlignment.
Реальный размер секции в адресном пространстве равен меньшему из двух рассчитанных значений.
Последний этап, это проверка - попадает ли переданный RVA адрес в диапазон адресов секций.

После того как мы определились с номером секции к которой принадлежит RVA адрес, необходимо произвести его конвертацию посредством следующей функции:

function TRawPEImage.RvaToRaw(RvaAddr: DWORD): DWORD;
var
  NumberOfSections: Integer;
  SectionData: TSectionData;
  SizeOfImage: DWORD;
  PointerToRawData: DWORD;
begin
  Result := 0;

  // ... граничные проверки вырезаны 

  if GetSectionData(RvaAddr, SectionData) then
  begin
    PointerToRawData := FSections[SectionData.Index].PointerToRawData;
    if FNtHeader.OptionalHeader.SectionAlignment >= DEFAULT_SECTION_ALIGNMENT then
      PointerToRawData := AlignDown(PointerToRawData, DEFAULT_FILE_ALIGNMENT);

    Inc(PointerToRawData, RvaAddr - SectionData.StartRVA);

    if PointerToRawData < FSizeOfFileImage then
      Result := PointerToRawData;
  end;
end;

В ней сначала происходит проверка редких ситуаций когда RVA адрес принадлежит заголовкам файла и второй случай, когда в файле вообще нет секций (случаи граничные, поэтому рассматривать не буду).
После чего происходит сама конвертация, из конвертируемого RVA адреса вычитается RVA адрес начала секции и к результату прибавляется PointerToRawData, указывающий на смещение секции относительно начала файла. Результатом будет RAW адрес, опираясь на который мы сможем прочитать данные из образа файла на диске.

Осталось написать еще одну утилитарную функцию, она пригодится для работы с адресами директорий, которые TRawPEImage хранит уже преобразованными в VA.

function TRawPEImage.VaToRaw(VaAddr: ULONG_PTR64): DWORD;
begin
  Result := RvaToRaw(VaToRva(VaAddr));
end;

Если проверить этот код на 'ntdll.dll' то в случае Win11 из 32 битного процесса (при этом будет подгружена библиотека из SysWOW64) данные будут такие:
RVA адрес директории экспорта = 0х110360
Принадлежит директории '.text', которая начинается с RVA 0x1000, размером 0х122800 байт, PointerToRawData = 0х400
В реальном файле RAW адрес директории экспорта будет равен: 0х110360 - 0x1000 + 0х400 = 0х10F760
Проверяем, открыв эту библиотеку в HEX редакторе и сравнив с тем что находится по VA адресу таблицы экспорта в процессе.

..\2.png

Как видим из скриншота - данные совпали, значит RAW адреса мы получаем правильно и пришло время читать саму таблицу экспорта напрямую из файла.
В качестве реципиента я взял маленькую библиотеку для работы с ACE архивами так как в ней более наглядно можно увидеть для чего предназначен каждый список таблицы экспорта. Итак, таблица экспорта функций начинается со структуры IMAGE_EXPORT_DIRECTORY, которую нам нужно прочитать самым первым шагом.

function TRawPEImage.LoadExport(Raw: TStream): Boolean;
var
  I, Index: Integer;
  LastOffset: Int64;
  ImageExportDirectory: TImageExportDirectory;
  FunctionsAddr, NamesAddr: array of DWORD;
  Ordinals: array of Word;
  ExportChunk: TExportChunk;
begin
  Result := False;
  LastOffset := VaToRaw(ExportDirectory.VirtualAddress);
  if LastOffset = 0 then Exit;
  Raw.Position := LastOffset;
  Raw.ReadBuffer(ImageExportDirectory, SizeOf(TImageExportDirectory));

  if ImageExportDirectory.NumberOfFunctions = 0 then Exit;

  // читаем префикс для перенаправления через ApiSet,
  // он не обязательно будет равен имени библиотеки
  // например:
  // kernel.appcore.dll -> appcore.dll
  // gds32.dll -> fbclient.dll
  Raw.Position := RvaToRaw(ImageExportDirectory.Name);
  if Raw.Position = 0 then
    Exit;
  FOriginalName := ReadString(Raw);

  // читаем масив Rva адресов функций
  SetLength(FunctionsAddr, ImageExportDirectory.NumberOfFunctions);
  Raw.Position := RvaToRaw(ImageExportDirectory.AddressOfFunctions);
  if Raw.Position = 0 then
    Exit;
  Raw.ReadBuffer(FunctionsAddr[0], ImageExportDirectory.NumberOfFunctions shl 2);

Вначале идет проверка, получилось ли преобразовать VA адрес директории в RAW (т.е. результат работы VaToRaw). Таких проверок будет по коду много, и если не забуду !!!!!!!!!, то я покажу в каком случае эти проверки могут сработать.
Особо отмечу - все адреса из структуры IMAGE_EXPORT_DIRECTORY представлены в виде RVA, т.е. для работы с ними всегда требуется преобразование, либо в RAW если читаем из файла, либо в VA если читаем из памяти!
Следующим шагом идет проверка количества экспортируемых функций, так как наличие директории экспорта еще не означает что в ней есть данные.
Далее читается имя библиотеки. Сейчас оно нам не интересно, но как можно увидеть в комментарии к коду, оно будет использоваться в дальнейшем (на этом я заострю внимание в главе про редиректы библиотек).
Ну и последним подготовительным шагом читается массив адресов экспортируемых функций. Это список DWORD-ов содержащий RVA адреса экспортируемых функций.
Давайте посмотрим как выглядит таблица экспорта для библиотеки UNACEV2.DLL

..\3.png

Вначале идет структура IMAGE_EXPORT_DIRECTORY и стрелками я показал на какие данные ссылаются её поля. Самое важное поля в ней это NumberOfFunctions + AddressOfFunctions.
Остальные поля со стрелками NumberOfNames + AddressOfNames + AddressOfNameOrdinals могут быть равны нулю, но NumberOfFunctions + AddressOfFunctions обязательно должны присутствовать, т.к. именно они дают возможность получить доступ к экспортируемым функциям хотя бы по их ORDINAL значению.

Итак синяя стрелка показывает на список экспортируемых функций. Давайте рассмотрим поподробнее самую первую запись:

03517034: 08 DB 00 00    EAT FuncAddr [1] UNACEV2.DLL!ACEInitDll = [34DDB08]

1. 03517034 - это адрес в котором хранится RVA значение экспортируемой функции ACEInitDll
2. 08 DB 00 00 - это 4 байта которые и являются RVA адресом функции. Если преобразовать их в DWORD это будет означать 0x0000DB08 (числа хранятся в памяти в little-endian формате, т.е. наоборот их привычному представлению).
3. EAT FuncAddr [1] - это комментарий к экспортируемой функции поясняющий тип адреса и в скобках содержащий ORDINAL экспортируемой функции.
4. UNACEV2.DLL!ACEInitDll = [34DDB08] - сама экспортируемая функция, а в скобках содержится её VA адрес, который вернет GetProcAddress (VA = RVA + ImageBase)
Из четвертого пункта можно понять что так как RVA равен 0xDB08, а VA адрес равен 0х34DDB08 то Instance библиотеки (адрес по которому она загружена) равен 0х034D0000

Если посмотрим на первый список, то увидим что все ординалы функций (в первых квадратных скобках) идут по порядку от единицы до шести. Это условие всегда будет соблюдаться, дело в том что это (как правило) тот порядок в котором они объявлены в коде библиотеки. Вот как они идут в коде, так обычно и прописываются в списке экспорта (это можно наглядно увидеть по их RVA или VA значениям, которые идут на увеличение, правда это не всегда так).
Обратите внимание что ординалы начинаются не от нуля, а от единицы. Дело в том что фактический ординал функции это её индекс (от нуля) сложенный со значением IMAGE_EXPORT_DIRECTORY.Base равный в данном случае единице (в ntdll например он равен восьми).

Более интересны два другие списка, в частности список на который указывает параметр AddressOfNames. Это список имен функций в количестве IMAGE_EXPORT_DIRECTORY.NumberOfNames объявленных строго в отсортированном порядке (обязательное условие), именно по этим именам идет поиск функции в случае вызова GetProcAddress, а сортировка нужна для ускорения поиска. Заметьте - имя функции это такой-же RVA указатель на буфер с именем (строго на Ansi буффер).
Как вы понимаете отсортированный список имен функций практически всегда не будет соответствовать их декларации из первого (AddressOfFunctions) списка, поэтому для соответствия какое имя какому адресу соответствует, существует третий список - AddressOfNameOrdinals. Это список двухбайтовых WORD, в количестве IMAGE_EXPORT_DIRECTORY.NumberOfNames каждый из которых соответствует (по индексу) такому же имени функции и содержащий индекс от нуля в самом первом списке AddressOfFunctions.

Хитрый момент. Обратите внимание - индекс всего два байта!
Именно из-за этого ограничения у вас не получится сделать библиотеку экспортирующую больше 65535 функций (я знаю людей, которые пробовали).

Впрочем, давайте прямо сейчас рассмотрим пример (сверяйтесь с картинкой выше).
1. читаем имя самой первой функции из списка AddressOfNames:
0351704C: 70 70 04 00    EAT Name [5] UNACEV2.DLL!ACEExtract = [3517070]
2. читаем соответствующий ей ординал индекс из списка AddressOfNameOrdinals
03517064: 04 00          EAT Ordinal [5] UNACEV2.DLL!ACEExtract = 4
3. видим что индекс равен четырем. Это реальный индекс от нуля в самом первом списке RVA адресов функций. Читаем четвертую запись из списка AddressOfFunctions:
03517044: 67 DD 00 00    FuncAddr [5] UNACEV2.DLL!ACEExtract = [34DDD67]
Ну а ORDINAL индекс этой функции равен индексу в списке + база, т.е. пяти.

Вот примерно такой-же алгоритм и напишем:

  // Важный момент!
  // Библиотека может вообще не иметь функций экспортируемых по имени,
  // только по ординалам. Пример такой библиотеки: mfperfhelper.dll
  // Поэтому нужно делать проверку на их наличие
  if ImageExportDirectory.NumberOfNames > 0 then
  begin

    // читаем массив Rva адресов имен функций
    SetLength(NamesAddr, ImageExportDirectory.NumberOfNames);
    Raw.Position := RvaToRaw(ImageExportDirectory.AddressOfNames);
    if Raw.Position = 0 then
      Exit;
    Raw.ReadBuffer(NamesAddr[0], ImageExportDirectory.NumberOfNames shl 2);

    // читаем массив ординалов - индексов через которые имена функций
    // связываются с массивом адресов
    SetLength(Ordinals, ImageExportDirectory.NumberOfNames);
    Raw.Position := RvaToRaw(ImageExportDirectory.AddressOfNameOrdinals);
    if Raw.Position = 0 then
      Exit;
    Raw.ReadBuffer(Ordinals[0], ImageExportDirectory.NumberOfNames shl 1);

    // сначала обрабатываем функции экспортируемые по имени
    for I := 0 to ImageExportDirectory.NumberOfNames - 1 do
    begin
      Raw.Position := RvaToRaw(NamesAddr[I]);
      if Raw.Position = 0 then Continue;

      // два параметра по которым будем искать фактические данные функции
      ExportChunk.FuncName := ReadString(Raw);
      ExportChunk.Ordinal := Ordinals[I];

      // VA адрес в котором должен лежать Rva линк на адрес функции
      // именно его изменяют при перехвате функции методом патча
      // таблицы экспорта.	  
      ExportChunk.ExportTableVA := RvaToVa(
        ImageExportDirectory.AddressOfFunctions + ExportChunk.Ordinal shl 2);

      // Смещение в RAW файле по которому лежит Rva линк
      ExportChunk.ExportTableRaw := VaToRaw(ExportChunk.ExportTableVA);

      // Само RVA значение которое будут подменять
      ExportChunk.FuncAddrRVA := FunctionsAddr[ExportChunk.Ordinal];

      // VA адрес функции, именно по этому адресу (как правило) устанавливают
      // перехватчик методом сплайсинга или хотпатча через трамплин
      ExportChunk.FuncAddrVA := RvaToVa(ExportChunk.FuncAddrRVA);

      // Raw адрес функции в образе бинарника с которым будет идти проверка
      // на измененные инструкции
      ExportChunk.FuncAddrRaw := RvaToRaw(ExportChunk.FuncAddrRVA);

      // вставляем признак что функция обработана
      FunctionsAddr[ExportChunk.Ordinal] := 0;

      // переводим в NameOrdinal который прописан в таблице импорта
      Inc(ExportChunk.Ordinal, ImageExportDirectory.Base);

      // добавляем в общий список для анализа снаружи
      Index := FExport.Add(ExportChunk);

      // vcl270.bpl спокойно декларирует 4 одинаковых функции
      // вот эти '@$xp$39System@%TArray__1$p17System@TMetaClass%'
      // с ординалами 7341, 7384, 7411, 7222
      // поэтому придется в массиве имен запоминать только самую первую
      // ибо линковаться они могут только через ординалы
      // upd: а они даже не линкуются, а являются дженериками с линком на класс
      // а в таблице экспорта полученном через Symbols присутствует только одна
      // с ординалом 7384
      FExportIndex.TryAdd(ExportChunk.FuncName, Index);

      // индекс для поиска по ординалу
      // (если тут упадет с дубликатом, значит что-то не верно зачитано)
      FExportOrdinalIndex.Add(ExportChunk.Ordinal, Index);
    end;
  end;
  
  
Что здесь происходит.
Самым первым шагом идет проверка, а есть ли вообще список имен? Если есть, то происходят все те же самые действия про которые я рассказал выше и заполняется структура в которой будет хранится информация по каждой экспортируемой функции. Её пока рассматривать не будем, она пригодится нам гораздо позже, когда будем писать анализатор.
Единственно что упомяну, это то что именно на этом этапе рассчитывается реальный VA адрес каждой функции на основе Instance библиотеки переданного в конструкторе класса, и хранится он в ExportChunk.FuncAddrVA, а также адрес по которому он будет хранится, это ExportChunk.ExportTableVA.
Оба этих адреса будет контролировать анализатор на следующих этапах, т.к. изменением значения на которое указывает ExportTableVA осуществляется установка перехватчика через правку таблицы экспорта, а правкой данных, которые указывает FuncAddrVA осуществляется установка перехватчика прямой правкой кода функции (не важно каким именно способом, через HotPatch или трамплин или вообще модификация поведения функции посредством изменения её кода целиком).

Для ускорения работы с классом помимо списка экспорта FExport используются два словаря.
1. Словарь имен функций FExportIndex
2. Словарь ординалов функций FExportOrdinalIndex
Это уже чисто организационные моменты, тут я их показал для демонстрации одного момента.
Дело в том что по правилам дубликатов в списке имен экспорта быть не должно, но как видно по комментарию к коду, дельфи вполне допускает такие дубликаты, правда момент заключается в том, что эти имена не принадлежат функциям как таковым, а указывают на некие публичные структуры. Такое может быть и в штатных библиотеках, например экспортируемая из ntdll RtlNtdllName фактически функцией не является, т.к. является просто указателем на строку.
Впрочем такие ситуации будут рассмотрены немного позже, когда будем расширять код класса, а сейчас остался последний шаг.
Данные по функциям экспортирующихся по имени мы загрузили, но есть очень много библиотек экспортирующих часть функций только по ординалам (без имени), поэтому третьим шагом нужно обработать такие оставшиеся функции, опираясь на значение FunctionsAddr[Index], которое обнуляется для обработанных ранее функций (или изначально было равно нулю из-за пропуска в списке ординалов).

Кстати по поводу списка адресов. Данный список может идти с разрывами, т.е. если простым языком, некоторые функции экспортируемые по ординалу могут отсутствовать. Тогда вместо RVA такой функции будет записан ноль, вот как в случае экспорта библиотеки cabinet.dll

..\4.png

Именно на такие пропуски и идет закладка, когда я упомянул что нужно проверять значение FunctionsAddr[Index]. Итак - последний шаг:

  // обработка функций экспортирующихся по индексу
  for I := 0 to ImageExportDirectory.NumberOfFunctions - 1 do
    if FunctionsAddr[I] <> 0 then
    begin
      // здесь все тоже самое за исключение что у функции нет имени
      // и её подгрузка осуществляется по её ординалу, который рассчитывается
      // от базы директории экспорта
      ExportChunk.FuncAddrRVA := FunctionsAddr[I];
      ExportChunk.Ordinal := ImageExportDirectory.Base + DWORD(I);
      ExportChunk.FuncName := EmptyStr;

      // сами значения рассчитываются как есть, без пересчета в ординал
      ExportChunk.ExportTableVA := RvaToVa(
        ImageExportDirectory.AddressOfFunctions + DWORD(I shl 2));

      ExportChunk.FuncAddrVA := RvaToVa(ExportChunk.FuncAddrRVA);
      ExportChunk.FuncAddrRaw := RvaToRaw(ExportChunk.FuncAddrRVA);

      // добавляем в общий список для анализа снаружи
      Index := FExport.Add(ExportChunk);

      // имени нет, поэтому добавляем только в индекс ординалов
      FExportOrdinalIndex.Add(ExportChunk.Ordinal, Index);
    end;
	
Ну вот собственно и все по чтению таблицы экспорта. Точнее это конечно же только первый этап, но для демонстрации правильности работы класса напишем небольшой тестовый пример.	

var
  Raw: TRawPEImage;
  hLib: THandle;
  ExportFunc: TExportChunk;
begin
  hLib := GetModuleHandle('ntdll.dll');
  Raw := TRawPEImage.Create('c:\windows\system32\ntdll.dll', ULONG64(hLib));
  try
    for ExportFunc in Raw.ExportList do
      if ExportFunc.FuncAddrVA <> ULONG64(GetProcAddress(hLib, PChar(ExportFunc.FuncName))) then
        Writeln(ExportFunc.FuncName, ' wrong addr: ', ExportFunc.FuncAddrVA);
  finally
    Raw.Free;
  end;
end.

В данном примере загружаем ntdll и сверяем рассчитанный адрес каждой экспортируемой функции с его реальным значением, полученным через вызов GetProcAddress.
Если все сделано правильно, то результатом выполнения будет только одна строчка
Export count: 2469

Полученный в результате код достаточен, чтобы перейти к следующему этапу.
Правда если меня сейчас читают люди полностью понимающие то что происходит в этой главе, пока не начинайте возмущаться что выполнены не все необходимые шаги по полноценной загрузке таблицы экспорта. Я про это в курсе, но на данном этапе они пока что не нужны - все будет, но чуть позже.