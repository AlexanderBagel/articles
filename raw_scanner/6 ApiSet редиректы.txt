6. ApiSet редиректы

Начиная с Windows 7 совершилась небольшая революция, в Windows было внедрено ядро MinWin. Скажем так это минимальная сборка Windows с самым необходимым набором функционала, что позволило в дальнейшем легко разрабатывать такие специализированные OS как Windows IoT, взамен Embedded.
Часть функционала из kernel32/user32/gdi32/etc... переехала в другие библиотеки, причем в зависимости от типа операционной системы, набор библиотек с конечным функционалом может меняться. А чтобы прикладной код был универсален, Microsoft придумала концепцию виртуальных библиотек.
Брались группы функций, например для работы с файлами (CreateFile/FindFirstFile/etc...), и переносились в библиотеку допустим "api-ms-win-core-file-l1-1-0.dll". И в самом начале, в Windows 7, эти библиотеки даже присутствовали в "c:\windows\system32\" и их можно было посмотреть. Сами они вообще не содержали никакого кода, и их задача была в предоставлении внешнему коду своей таблицы экспорта в которой были объявлены записи о всех функциях с их редиректами к библиотеке, содержащей реальный код функций. Впрочем их наличие никаких плюсов не давало, т.к. загрузка таких библиотек через LoadLibrary возвращала ошибку ERROR_DLL_INIT_FAILED, а сейчас, в Windows 11 этих библиотек вообще нет, да они в принципе и не нужны.
Как это работает: все функции, реализация которых перенесена в ядро MinWin (их достаточно большой список), указываются в таблицах импорта/экспорта не с указанием имени библиотеки, которая их реализует, а с указанием именно таких промежуточных виртуальных библиотек, именно они были показаны на последнем скриншоте. Загрузчик при инициализации таблиц импорта/экспорта производит подмену виртуальных библиотек на реальные, реализующие финальный код функции после чего процесс может нормально запустится, т.к. все адреса у него актуализированы.

А делает он такой редирект на основе специальной служебной таблицы, называемой ApiSet Map, расположеной в библиотеке apisetschema.dll ввиде отдельной секции ".apiset" причем эта библиотека не подгружается в процесс, отмапливается только сама секция. И вот формат этой секции представляет наибольший интерес.

Во первых он абсолютно не документирован, во вторых на текущий момент существует три версии данного формата.
- версия два, используется в Windows 7 и Windows 8
- версия четыре используется в Windows 8.1
- версия шесть используется в Windows 10 и Windows 11
Для того чтобы код анализатора правильно работал на всех версиях OS, он должен уметь читать все три формата этой таблицы.
Ну а в третьих данная таблица присутствует в каждом процессе и нет необходимости её чтения из чужого адресного пространства, достаточно её прочитать у самого себя.

Ссылка на адрес памяти, содержащий отмапленный ApiSet расположена в блоке окружения процесса (PEB), это именно та структура, посредством которой происходило чтение данных из таблиц загрузчика. Так как чтение таблицы может (и будет) происходить из текущего процесса, то получение необходимого адреса упрощается и сводится всего лишь к паре ассемблерных строк:

function TApiSetRedirector.GetPEBApiSet: Pointer;
asm
  {$IFDEF WIN32}
  mov eax, fs:[30h]
  mov eax, [eax + 38h]
  {$ELSE}
  mov rax, gs:[60h]
  mov rax, [rax + 68h]
  {$ENDIF}
end;

Здесь, посредством регистра FS (или GS для 64 бит), который указывает на блок окружения потока (TEB), читается адрес структуры PEB (смещение поля TEB->ProcessEnvironmentBlock равно 0х30 и 0х60 для 32 и 64 бит соответственно), после чего читается значение поля PEB->ApiSetMap (смещение 0х38 и 0х68 для 32 и 64 бит соответственно).

Сразу же упомяну о двух моментах, чтобы не останавливаться на них позже. 
1. Все структуры описанные ниже, содержат адреса в RVA формате, но базой, от которой идет отсчет RVA адреса, является адрес самой таблицы, который бул получен кодом выше. Т.е. если в какой-то структуре содержится число 0х123, а таблица размещается в памяти по адресу 0х30000, то это означает что VA адрес будет равен 0х30123! 
2. Во всех форматах ApiSet таблицы строки хранятся в виде вот такой структуры:

  TApiSetString = record
    Offset: ULONG;
    Length: USHORT;
  end;
  
Где Offset - это RVA адрес UNICODE строки (не Ansi), а Length - её длина в байтах (не в символах).

После получения адреса ApiSet таблицы нужно определится в каком формате она представлены, за это отвечает самое первое поле заголовка таблицы, представляющее из себя LONG, в котором будет записана версия 2, 4 или 6:

procedure TApiSetRedirector.Init;
begin
  FApiSetVer := PLONG(FApiSet)^;
  case FApiSetVer of
    2: Init2;
    4: Init4;
    6: Init6;
  end;
end;

Начну с самого простого формата за номером два.

Он представляет из себя четыре структуры.
1. Заголовок таблицы: 

  TApiSetNameSpace2 = record
    Version,
    Count: ULONG;
  end;
  
С него начинается ApiSet таблица второй версии и задача этой структуры, сообщить, помимо версии, о количестве содержащихся в ней записей о редиректе.

2. Сразу за ней идет массив структур TApiSetNameSpaceEntry2, в количестве, указанном в заголовке таблицы.

  TApiSetNameSpaceEntry2 = record
    Name: TApiSetString;
    DataOffset: ULONG;
  end;
  
Поле Name, это и есть искомая строка редиректа, выглядит обычно вот в таком виде с учетом регистра (если прочитать через TApiSetString): "MS-Win-Core-ErrorHandling-L1-1-0". Этой строке будет соответствовать запись в таблицах импорта/экспорта примерно такого вида:
 - или "api-ms-win-core-errorhandling-l1-1-0.dll" 
 - или "ext-ms-win-core-errorhandling-l1-1-0.dll"
Я не смог найти информацию по какому правилу добавляется тот или иной префикс, поэтому при чтении ApiSet таблицы второй (и четвертой) версии, просто добавляю в словарь сразу две записи с каждым из префиксов.

Поле DataOffset - RVA адрес следующей структуры:

  TApiSetValueEntry2 = record
    NumberOfRedirections: ULONG;    
  end; 

Она представляет из себя всего одно поле, обозначающее количество возможных вариантов редиректа, сразу за которой идет массив структур, описывающих куда именно нужно произвести редирект в количестве NumberOfRedirections:

  TApiSetValueEntryRedirection2 = record
    Name: TApiSetString;
    Value: TApiSetString;
  end;
  
И вот тут достаточно интересный момент. Самое первое поле Name представляет из себя по сути фильтр, уточняющий в каких случаях данный редирект должен применяться и содержит в себе либо имя библиотеки, либо остается пустым.
А вот второе поле указывает на какую конкретно библиотеку произойдет редирект.

Давайте посмотрим на картинку:

../18.png

ApiSetValueEntry2 содержит в себе число два, и сразу за ней идут две записи, причем первая перенаправляет в kernel32.dll (поле Value), а вторая в kernelbase.dll, причем у второй указано что Name равен kernel32.dll.
Как это работает: например nsi.dll имеет в импорте запись об GetLastError которую экспортирует API-MS-Win-Core-ErrorHandling-L1-1-0.dll
По умолчанию для всех библиотек включается редирект на kernel32.dll, но и сам kernel32.dll в таблице импорта имеет запись об GetLastError (на которую еще и форвард идет из таблицы экспорта), причем из той-же библиотеки API-MS-Win-Core-ErrorHandling-L1-1-0.dll.
Вот для такой ситуации в ApiSet включена запись что kernel32.dll должна быть перенаправлена не в саму себя, а в kernelbase.dll

Схематично вторая версия ApiSet таблицы выглядит в виде вот такого дерева:

  TApiSetNameSpace2                          // количество виртуальных библиотек
      TApiSetNameSpaceEntry2                 // вирт библиотека "API-MS-Win-Core-Console-L1-1-0.dll"
	  TApiSetNameSpaceEntry2                 // вирт библиотека "API-MS-Win-Core-DateTime-L1-1-0.dll"
	  TApiSetNameSpaceEntry2                 // вирт библиотека "API-MS-Win-Core-Debug-L1-1-0.dll"
	  TApiSetNameSpaceEntry2                 // вирт библиотека "API-MS-Win-Core-DelayLoad-L1-1-0.dll"
	  TApiSetNameSpaceEntry2                 // вирт библиотека "API-MS-Win-Core-ErrorHandling-L1-1-0.dll"
	      TApiSetValueEntry2                 // количество вариантов редиректов 
		      TApiSetValueEntryRedirection2  // описание редиректа по умолчанию
			  TApiSetValueEntryRedirection2  // описание дополнительного условия редиректа
  ...

И код её чтения:

procedure TApiSetRedirector.Init2;
...
begin
  NameSpaceEntry := PApiSetNameSpaceEntry2(PByte(FApiSet) + SizeOf(TApiSetNameSpace2));
  for I := 0 to PApiSetNameSpace2(FApiSet)^.Count - 1 do
  begin
    LibFrom := GetString(NameSpaceEntry.Name).ToLower;
    ValueEntry := Pointer(PByte(FApiSet) + NameSpaceEntry.DataOffset);
    EntryRedirection := Pointer(PByte(ValueEntry) + SizeOf(TApiSetValueEntry2));
    for A := 0 to ValueEntry.NumberOfRedirections - 1 do
    begin
      Redirection := GetString(EntryRedirection.Value);
      Key := LibFrom + GetString(EntryRedirection.Name);
      AddRedirection(Key, Redirection);
      Inc(EntryRedirection);
    end;
    Inc(NameSpaceEntry);
  end;
end;

В этом коде всего два нюанса:
1. все RVA адреса пересчитываются в VA сложением с адресом самой таблицы (эту адресацию я уже упомянул в самом начале, но на всякий случай).
2. формирование ключа для поиска редиректа. Для всех случаев он хранится как имя виртуальной библиотеки, т.е. "api-ms-win-core-errorhandling-l1-1-0", а частные случаи для конкретных библиотек, хранятся с указанием имени этой библиотеки: "api-ms-win-core-errorhandling-l1-1-0kernel32.dll"
Это пригодится в дальнейшем для быстрого поиска редиректа.

Теперь формат таблицы за номером четыре, который применяется в Windows 8.1

Заголовок выглядит в виде такой структуры:

  TApiSetNameSpace4 = record
    Version,
    Size,
    Flags,
    Count: ULONG;
  end;
  
По сравнению со второй версией добавились поля Size, содержащий полный размер ApiSet таблицы в байтах, и поле Flags - которое (по идее) должно содержать какие-то флаги, значения и назначение которых мне не известны. На моих тестовых стендах это поле всегда было равно нулю.

Далее все так-же идет массив структур TApiSetNameSpaceEntry4, в количестве, указанном в заголовке таблицы.

  TApiSetNameSpaceEntry4 = record
    Flags: ULONG;
    Name: TApiSetString;
    Alias: TApiSetString;
    DataOffset: ULONG;     
  end;
  
Здесь появилось два новых поля, назначение которых мне так-же не известно, это Flags (содержит либо единицу либо тройку), и поле Alias - содержащее сокращенное имя виртуальной библиотеки (применение не известно). Остальные поля остались старыми и работают так-же, т.е. DataOffset - это RVA адрес на структуру:

  TApiSetValueEntry4 = record
    Flags,
    NumberOfRedirections: ULONG;    
  end;
  
Опять, появилось поле с каким-то флагом, что делает - не понятно (на тесте всегда равен нулю).
Ну и сразу за ним, также как и во второй версии ApiSet, идет массив реальных редиректов:

  TApiSetValueEntryRedirection4 = record
    Flags: ULONG;
    Name: TApiSetString;
    Value: TApiSetString;
  end;
  
Кроме дополнительного поля флага (который всегда равен нулю), ничего не поменялось. Таким образом, структура и код чтения четвертой версии ApiSet таблицы, ничем не отличается, за исключением что используются новые версии структур с дополнительным и не влияющими ни на что, полями.

А вот ApiSet версии шесть, который пошел начиная с Windows 10 и продолжает используется в Windows 11, устроен немножко хитрее.

Заголовок выглядит следующим образом:

  TApiSetNameSpace6 = record
    Version,                
    Size,                   
    Flags,                  
    Count,                  
    EntryOffset,            
    HashOffset,             
    HashFactor: ULONG;      
  end;
  
По сравнению с заголовком четвертой версии добавились три поля:
1. Поле EntryOffset, который является RVA адресом начала массива редиректов. Раньше они шли сразу за заголовком (впрочем в шестой версии тоже идут сразу за ним), но наличие этого поля подразумевает что ситуация в какой-то момент времени может изменится и они могут быть перемещены по любом другому произвольному адресу.
2. Поле HashOffset, новое понятие для ApiSet таблиц, майкрософт решило ускорить работу с таблицей и добавило в неё хэши имен виртуальных библиотек. Это поле хранит RVA указатель на начало массива структур описывающих хэш к каждой записи. Если честно мне этот механизм показался не удобным поэтому в коде я использую обычный словарь, который справляется с хранением имен библиотек намного удобнее и применим к любой версии ApiSet, поэтому это поле в коде будет игнорироваться.
3. HashFactor - это поле содержит число от которого начинает считаться хэш, тоже не интересно.

Сразу за заголовком, ну если быть точнее, по адресу, на который указывает EntryOffset идет массив структур:

  TApiSetNameSpaceEntry6 = record
    Flags: ULONG;           
    Name: TApiSetString;    
    HashedLength: ULONG;    
    ValueOffset,            
    ValueCount: ULONG;      
  end;
  
Поле Flags - некоторые источники утверждают что это поле хранит флаг Sealed равный единице, за что он отвечает, не известно, но он выставлен у всех записей.
Поле Name - это искомое имя виртуальной библиотеки. Причем в отличии от младших версий, оно представлено целиком со всеми необходимыми префиксами, например вот так: "api-ms-win-core-errorhandling-l1-1-3"
Поле HashedLength - а вот это размер имени библиотеки в байтах с которой должен сниматься хэш. Очень важное поле, т.к. имя виртуальной библиотеки, 
имеет свою версионность, например errorhandling в Windows 7 заканчивался цифрой ноль, на Windows 8.1 вообще присутствует две записи, с версией ноль и с версией один, в Windows 10 она идет с цифрой два, а в Windows 11 - три. Старые же версии программ содержат привязку к актуальным на момент их сборки наименованиям виртуальных библиотек, и параметр HashedLength указывает размер наименования, который будет одинаков для всех без учета версионности, таким образом давая возможность запуска старым сборкам программ.
Поле ValueOffset - аналог старого поля DataOffset, содержит RVA адрес на массив структур редиректа
Поле ValueCount - новое поле, которое заменяет собой старую структуру TApiSetValueEntryХ и содержит размер массива редиректов для виртуальной библиотеки.

А вот структура использующаяся в массиве редиректов не поменялась и осталась по наполнению полей такая-же как и в версии четыре формата ApiSet таблицы. Но и в ней произошли небольшие изменения. В предыдущих версиях формата указывалось имя библиотеки для редиректа (поле Value), и описывались особые случаи когда применялся другой тип редиректа (поле Name), в шестой же версии формата редирект вообще может быть указан пустым.
Это применимо для модулей ядра, например ntoskrnl.exe который имеет редирект на виртуальную библиотеку "ext-ms-win-ntos-ksecurity-l1-1" ну и несколько других сугубо специфичных для ядра. Такой исполняемый файл может быть подгружен в адресное пространство процесса (я упоминал про это в пятой главе) но его таблица импорта будет свернута в самого себя на заглушки, поэтому такие модули с IMAGE_SUBSYSTEM_NATIVE не обрабатываются и редиректы для таких виртуальных библиотек пустые.

Раз структура по сути не поменялась, то показывать её декларацию я не буду, а вместо неё покажу структуру описывающую хэш имени. 
Она использоваться не будет, поэтому просто для справки.

  TApiSetHashEntry6 = record
    Hash,
    Index: ULONG;
  end;
  
Код чтения шестой версии таблицы такой:

procedure TApiSetRedirector.Init6;
...
begin
  NameSpaceEntry := PApiSetNameSpaceEntry6(PByte(FApiSet) +
    PApiSetNameSpace6(FApiSet)^.EntryOffset);
  for I := 0 to PApiSetNameSpace6(FApiSet)^.Count - 1 do
  begin
    LibFrom := GetString(NameSpaceEntry.Name);
    SetLength(LibFrom, NameSpaceEntry.HashedLength div SizeOf(Char));
    ValueEntry := Pointer(PByte(FApiSet) + NameSpaceEntry.ValueOffset);
    for A := 0 to NameSpaceEntry.ValueCount - 1 do
    begin
      Redirection := GetString(ValueEntry.Value);
      Key := LibFrom + GetString(ValueEntry.Name);
      if not Redirection.IsEmpty then
      begin
        Inc(FUniqueCount);
        FData.AddOrSetValue(Key, Redirection);
      end;
      Inc(ValueEntry);
    end;
    Inc(NameSpaceEntry);
  end;
end;

Это собственно все по поводу чтения, теперь нужно подключить ApiSet редиректы к загрузчику модулей TRawPEImage.
Для этого необходимы два метода доступных снаружи для обработки редиректа:

function TApiSetRedirector.RemoveSuffix(const Value: string): string;
var
  LastSuffixIndex: Integer;
begin
  if FApiSetVer = 6 then
  begin
    LastSuffixIndex := Value.LastDelimiter('-');
    if LastSuffixIndex > 0 then
      Exit(Copy(Value, 1, LastSuffixIndex));
  end;
  Result := Value;
end;

function TApiSetRedirector.SchemaPresent(const LibName: string;
  var RedirectTo: string): Boolean;
var
  Tmp: string;
begin
  if FData.Count = 0 then Exit(False);
  Tmp := RemoveSuffix(RedirectTo.ToLower);
  // сначала получаем с привязкой к текущей библиотеке
  Result := FData.TryGetValue(Tmp + LibName.ToLower, RedirectTo);
  // а если нет записи, то получаем перенаправление по умолчанию
  if not Result then
    Result := FData.TryGetValue(Tmp, RedirectTo);
end;

Функция RemoveSuffix отвечает за изъятие версионной метки из имени виртуальной библиотеки, в случае если используется ApiSet версии шесть, а SchemaPresent производит поиск редиректа, соответствующий имени виртуальной библиотеки в комбинации с именем библиотеки из которой идет вызов (для обработки специальных ситуаций когда должен быть применен отдельный редирект, а не общий).

Инизиализация ApiSet редиректора нужно произвести при открытии процесса, для этого в процедуре TRawScanner.InitFromProcess в самом начале обьявляется вызов ApiSetRedirector.LoadApiSet;

В загрузчике модулей необходимо добавить метод работы с редиректором:

procedure TRawPEImage.InternalProcessApiSetRedirect(const LibName: string;
  var RedirectTo: string);
var
  ForvardLibraryName, FuncName: string;
begin
  if not ParceForvardedLink(RedirectTo, ForvardLibraryName, FuncName) then
    Exit;
  ForvardLibraryName := ChangeFileExt(ForvardLibraryName, '');
  if ApiSetRedirector.SchemaPresent(LibName, ForvardLibraryName) then
    RedirectTo := ChangeFileExt(ForvardLibraryName, '.') + FuncName;
end;

Его задачей будет преобразовывать вызовы ведущие в виртуальные библиотеки, на вызовы идущие к конечным, в которых реализован реальный код функций.
Например при входных данных:
LibName = 'KERNEL32.dll'
RedirectTo = 'api-ms-win-core-libraryloader-l1-1-0.AddDllDirectory'
RedirectTo преобразуется в 'kernelbase.AddDllDirectory'

Ну а вызов этого метода будет размещен в двух заглушках ProcessApiSetRedirect обрабатывающих импорт и экспорт.
Теперь, если запустить код демопримера, можно увидеть что он отработал без ошибок и вывел в консоль только список загруженных библиотек без ошибок, которые присутствовали в коде предыдущей главы.

Но это еще не все - есть еще таблица отложенного импорта, и её тоже нужно контролировать.